<?php
/*
 * DeskPRO (r) has been developed by DeskPRO Ltd. https://www.deskpro.com/
 * a British company located in London, England.
 *
 * All source code and content Copyright (c) 2017, DeskPRO Ltd.
 *
 * The license agreement under which this software is released
 * can be found at https://www.deskpro.com/eula/
 *
 * By using this software, you acknowledge having read the license
 * and agree to be bound thereby.
 *
 * Please note that DeskPRO is not free software. We release the full
 * source code for our software because we trust our users to pay us for
 * the huge investment in time and energy that has gone into both creating
 * this software and supporting our customers. By providing the source code
 * we preserve our customers' ability to modify, audit and learn from our
 * work. We have been developing DeskPRO since 2001, please help us make it
 * another decade.
 *
 * Like the work you see? Think you could make it better? We are always
 * looking for great developers to join us: http://www.deskpro.com/jobs/
 *
 * ~ Thanks, Everyone at Team DeskPRO
 */

/**
 * ContentApi
 * PHP version 5
 *
 * @category Class
 * @package  DeskPRO\API
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * DeskPRO API
 *
 * DeskPRO API
 *
 * OpenAPI spec version: 2.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace DeskPRO\API\Client;

use Psr\Http\Message\ResponseInterface;
use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use DeskPRO\API\ApiException;
use DeskPRO\API\Configuration;
use DeskPRO\API\HeaderSelector;
use DeskPRO\API\ObjectSerializer;

/**
 * ContentApi Class Doc Comment
 *
 * @category Class
 * @package  DeskPRO\API
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ContentApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;
    
    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        Configuration $config = null,
        ClientInterface $client = null,
        HeaderSelector $selector = null
    ) {
        $this->config = $config ?: new Configuration();
        $this->client = $client ?: new Client();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation deleteArticleById
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function deleteArticleById($id)
    {
        list($response) = $this->deleteArticleByIdWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation deleteArticleByIdWithHttpInfo
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteArticleByIdWithHttpInfo($id)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->deleteArticleByIdRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteArticleByIdAsync
     *
     * 
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteArticleByIdAsync($id)
    {
        return $this->deleteArticleByIdAsyncWithHttpInfo($id)
            ->then(
                function (array $response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteArticleByIdAsyncWithHttpInfo
     *
     * 
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteArticleByIdAsyncWithHttpInfo($id)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->deleteArticleByIdRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function (ResponseInterface $response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (RequestException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteArticleById'
     *
     *
     * @param int $id The id of the resource
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteArticleByIdRequest($id)
    {
        if (empty($id)) {
            throw new \InvalidArgumentException('Missing parameter "$id" in ContentApi::deleteArticleByIdRequest().');
        }
        

        $resourcePath = '/articles/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($id !== null) {
            $id = ObjectSerializer::toQueryValue($id);
        }
        

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteArticleCategoryById
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function deleteArticleCategoryById($id)
    {
        list($response) = $this->deleteArticleCategoryByIdWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation deleteArticleCategoryByIdWithHttpInfo
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteArticleCategoryByIdWithHttpInfo($id)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->deleteArticleCategoryByIdRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteArticleCategoryByIdAsync
     *
     * 
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteArticleCategoryByIdAsync($id)
    {
        return $this->deleteArticleCategoryByIdAsyncWithHttpInfo($id)
            ->then(
                function (array $response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteArticleCategoryByIdAsyncWithHttpInfo
     *
     * 
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteArticleCategoryByIdAsyncWithHttpInfo($id)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->deleteArticleCategoryByIdRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function (ResponseInterface $response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (RequestException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteArticleCategoryById'
     *
     *
     * @param int $id The id of the resource
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteArticleCategoryByIdRequest($id)
    {
        if (empty($id)) {
            throw new \InvalidArgumentException('Missing parameter "$id" in ContentApi::deleteArticleCategoryByIdRequest().');
        }
        

        $resourcePath = '/article_categories/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($id !== null) {
            $id = ObjectSerializer::toQueryValue($id);
        }
        

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteArticleCommentById
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function deleteArticleCommentById($id)
    {
        list($response) = $this->deleteArticleCommentByIdWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation deleteArticleCommentByIdWithHttpInfo
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteArticleCommentByIdWithHttpInfo($id)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->deleteArticleCommentByIdRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteArticleCommentByIdAsync
     *
     * 
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteArticleCommentByIdAsync($id)
    {
        return $this->deleteArticleCommentByIdAsyncWithHttpInfo($id)
            ->then(
                function (array $response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteArticleCommentByIdAsyncWithHttpInfo
     *
     * 
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteArticleCommentByIdAsyncWithHttpInfo($id)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->deleteArticleCommentByIdRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function (ResponseInterface $response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (RequestException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteArticleCommentById'
     *
     *
     * @param int $id The id of the resource
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteArticleCommentByIdRequest($id)
    {
        if (empty($id)) {
            throw new \InvalidArgumentException('Missing parameter "$id" in ContentApi::deleteArticleCommentByIdRequest().');
        }
        

        $resourcePath = '/article_comments/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($id !== null) {
            $id = ObjectSerializer::toQueryValue($id);
        }
        

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteArticlePendingCreateById
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function deleteArticlePendingCreateById($id)
    {
        list($response) = $this->deleteArticlePendingCreateByIdWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation deleteArticlePendingCreateByIdWithHttpInfo
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteArticlePendingCreateByIdWithHttpInfo($id)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->deleteArticlePendingCreateByIdRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteArticlePendingCreateByIdAsync
     *
     * 
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteArticlePendingCreateByIdAsync($id)
    {
        return $this->deleteArticlePendingCreateByIdAsyncWithHttpInfo($id)
            ->then(
                function (array $response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteArticlePendingCreateByIdAsyncWithHttpInfo
     *
     * 
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteArticlePendingCreateByIdAsyncWithHttpInfo($id)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->deleteArticlePendingCreateByIdRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function (ResponseInterface $response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (RequestException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteArticlePendingCreateById'
     *
     *
     * @param int $id The id of the resource
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteArticlePendingCreateByIdRequest($id)
    {
        if (empty($id)) {
            throw new \InvalidArgumentException('Missing parameter "$id" in ContentApi::deleteArticlePendingCreateByIdRequest().');
        }
        

        $resourcePath = '/article_pending_creates/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($id !== null) {
            $id = ObjectSerializer::toQueryValue($id);
        }
        

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteDownloadById
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function deleteDownloadById($id)
    {
        list($response) = $this->deleteDownloadByIdWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation deleteDownloadByIdWithHttpInfo
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteDownloadByIdWithHttpInfo($id)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->deleteDownloadByIdRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteDownloadByIdAsync
     *
     * 
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDownloadByIdAsync($id)
    {
        return $this->deleteDownloadByIdAsyncWithHttpInfo($id)
            ->then(
                function (array $response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteDownloadByIdAsyncWithHttpInfo
     *
     * 
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDownloadByIdAsyncWithHttpInfo($id)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->deleteDownloadByIdRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function (ResponseInterface $response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (RequestException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteDownloadById'
     *
     *
     * @param int $id The id of the resource
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteDownloadByIdRequest($id)
    {
        if (empty($id)) {
            throw new \InvalidArgumentException('Missing parameter "$id" in ContentApi::deleteDownloadByIdRequest().');
        }
        

        $resourcePath = '/downloads/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($id !== null) {
            $id = ObjectSerializer::toQueryValue($id);
        }
        

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteDownloadCategoryById
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function deleteDownloadCategoryById($id)
    {
        list($response) = $this->deleteDownloadCategoryByIdWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation deleteDownloadCategoryByIdWithHttpInfo
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteDownloadCategoryByIdWithHttpInfo($id)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->deleteDownloadCategoryByIdRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteDownloadCategoryByIdAsync
     *
     * 
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDownloadCategoryByIdAsync($id)
    {
        return $this->deleteDownloadCategoryByIdAsyncWithHttpInfo($id)
            ->then(
                function (array $response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteDownloadCategoryByIdAsyncWithHttpInfo
     *
     * 
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDownloadCategoryByIdAsyncWithHttpInfo($id)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->deleteDownloadCategoryByIdRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function (ResponseInterface $response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (RequestException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteDownloadCategoryById'
     *
     *
     * @param int $id The id of the resource
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteDownloadCategoryByIdRequest($id)
    {
        if (empty($id)) {
            throw new \InvalidArgumentException('Missing parameter "$id" in ContentApi::deleteDownloadCategoryByIdRequest().');
        }
        

        $resourcePath = '/download_categories/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($id !== null) {
            $id = ObjectSerializer::toQueryValue($id);
        }
        

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteDownloadCommentById
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function deleteDownloadCommentById($id)
    {
        list($response) = $this->deleteDownloadCommentByIdWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation deleteDownloadCommentByIdWithHttpInfo
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteDownloadCommentByIdWithHttpInfo($id)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->deleteDownloadCommentByIdRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteDownloadCommentByIdAsync
     *
     * 
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDownloadCommentByIdAsync($id)
    {
        return $this->deleteDownloadCommentByIdAsyncWithHttpInfo($id)
            ->then(
                function (array $response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteDownloadCommentByIdAsyncWithHttpInfo
     *
     * 
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDownloadCommentByIdAsyncWithHttpInfo($id)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->deleteDownloadCommentByIdRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function (ResponseInterface $response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (RequestException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteDownloadCommentById'
     *
     *
     * @param int $id The id of the resource
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteDownloadCommentByIdRequest($id)
    {
        if (empty($id)) {
            throw new \InvalidArgumentException('Missing parameter "$id" in ContentApi::deleteDownloadCommentByIdRequest().');
        }
        

        $resourcePath = '/download_comments/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($id !== null) {
            $id = ObjectSerializer::toQueryValue($id);
        }
        

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteGuideById
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function deleteGuideById($id)
    {
        list($response) = $this->deleteGuideByIdWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation deleteGuideByIdWithHttpInfo
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteGuideByIdWithHttpInfo($id)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->deleteGuideByIdRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteGuideByIdAsync
     *
     * 
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteGuideByIdAsync($id)
    {
        return $this->deleteGuideByIdAsyncWithHttpInfo($id)
            ->then(
                function (array $response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteGuideByIdAsyncWithHttpInfo
     *
     * 
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteGuideByIdAsyncWithHttpInfo($id)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->deleteGuideByIdRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function (ResponseInterface $response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (RequestException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteGuideById'
     *
     *
     * @param int $id The id of the resource
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteGuideByIdRequest($id)
    {
        if (empty($id)) {
            throw new \InvalidArgumentException('Missing parameter "$id" in ContentApi::deleteGuideByIdRequest().');
        }
        

        $resourcePath = '/guides/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($id !== null) {
            $id = ObjectSerializer::toQueryValue($id);
        }
        

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteNewsById
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function deleteNewsById($id)
    {
        list($response) = $this->deleteNewsByIdWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation deleteNewsByIdWithHttpInfo
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteNewsByIdWithHttpInfo($id)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->deleteNewsByIdRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteNewsByIdAsync
     *
     * 
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNewsByIdAsync($id)
    {
        return $this->deleteNewsByIdAsyncWithHttpInfo($id)
            ->then(
                function (array $response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteNewsByIdAsyncWithHttpInfo
     *
     * 
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNewsByIdAsyncWithHttpInfo($id)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->deleteNewsByIdRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function (ResponseInterface $response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (RequestException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteNewsById'
     *
     *
     * @param int $id The id of the resource
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteNewsByIdRequest($id)
    {
        if (empty($id)) {
            throw new \InvalidArgumentException('Missing parameter "$id" in ContentApi::deleteNewsByIdRequest().');
        }
        

        $resourcePath = '/news/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($id !== null) {
            $id = ObjectSerializer::toQueryValue($id);
        }
        

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteNewsCategoryById
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function deleteNewsCategoryById($id)
    {
        list($response) = $this->deleteNewsCategoryByIdWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation deleteNewsCategoryByIdWithHttpInfo
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteNewsCategoryByIdWithHttpInfo($id)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->deleteNewsCategoryByIdRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteNewsCategoryByIdAsync
     *
     * 
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNewsCategoryByIdAsync($id)
    {
        return $this->deleteNewsCategoryByIdAsyncWithHttpInfo($id)
            ->then(
                function (array $response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteNewsCategoryByIdAsyncWithHttpInfo
     *
     * 
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNewsCategoryByIdAsyncWithHttpInfo($id)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->deleteNewsCategoryByIdRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function (ResponseInterface $response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (RequestException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteNewsCategoryById'
     *
     *
     * @param int $id The id of the resource
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteNewsCategoryByIdRequest($id)
    {
        if (empty($id)) {
            throw new \InvalidArgumentException('Missing parameter "$id" in ContentApi::deleteNewsCategoryByIdRequest().');
        }
        

        $resourcePath = '/news_categories/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($id !== null) {
            $id = ObjectSerializer::toQueryValue($id);
        }
        

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteNewsCommentById
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function deleteNewsCommentById($id)
    {
        list($response) = $this->deleteNewsCommentByIdWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation deleteNewsCommentByIdWithHttpInfo
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteNewsCommentByIdWithHttpInfo($id)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->deleteNewsCommentByIdRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteNewsCommentByIdAsync
     *
     * 
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNewsCommentByIdAsync($id)
    {
        return $this->deleteNewsCommentByIdAsyncWithHttpInfo($id)
            ->then(
                function (array $response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteNewsCommentByIdAsyncWithHttpInfo
     *
     * 
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNewsCommentByIdAsyncWithHttpInfo($id)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->deleteNewsCommentByIdRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function (ResponseInterface $response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (RequestException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteNewsCommentById'
     *
     *
     * @param int $id The id of the resource
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteNewsCommentByIdRequest($id)
    {
        if (empty($id)) {
            throw new \InvalidArgumentException('Missing parameter "$id" in ContentApi::deleteNewsCommentByIdRequest().');
        }
        

        $resourcePath = '/news_comments/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($id !== null) {
            $id = ObjectSerializer::toQueryValue($id);
        }
        

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteTopicById
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function deleteTopicById($id)
    {
        list($response) = $this->deleteTopicByIdWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation deleteTopicByIdWithHttpInfo
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteTopicByIdWithHttpInfo($id)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->deleteTopicByIdRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteTopicByIdAsync
     *
     * 
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTopicByIdAsync($id)
    {
        return $this->deleteTopicByIdAsyncWithHttpInfo($id)
            ->then(
                function (array $response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteTopicByIdAsyncWithHttpInfo
     *
     * 
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTopicByIdAsyncWithHttpInfo($id)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->deleteTopicByIdRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function (ResponseInterface $response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (RequestException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteTopicById'
     *
     *
     * @param int $id The id of the resource
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteTopicByIdRequest($id)
    {
        if (empty($id)) {
            throw new \InvalidArgumentException('Missing parameter "$id" in ContentApi::deleteTopicByIdRequest().');
        }
        

        $resourcePath = '/topics/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($id !== null) {
            $id = ObjectSerializer::toQueryValue($id);
        }
        

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getArticleById
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getArticleById($id)
    {
        list($response) = $this->getArticleByIdWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getArticleByIdWithHttpInfo
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getArticleByIdWithHttpInfo($id)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getArticleByIdRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getArticleByIdAsync
     *
     * 
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArticleByIdAsync($id)
    {
        return $this->getArticleByIdAsyncWithHttpInfo($id)
            ->then(
                function (array $response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getArticleByIdAsyncWithHttpInfo
     *
     * 
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArticleByIdAsyncWithHttpInfo($id)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getArticleByIdRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function (ResponseInterface $response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (RequestException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getArticleById'
     *
     *
     * @param int $id The id of the resource
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getArticleByIdRequest($id)
    {
        if (empty($id)) {
            throw new \InvalidArgumentException('Missing parameter "$id" in ContentApi::getArticleByIdRequest().');
        }
        

        $resourcePath = '/articles/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($id !== null) {
            $id = ObjectSerializer::toQueryValue($id);
        }
        

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getArticleCategories
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getArticleCategories(array $filters = [])
    {
        list($response) = $this->getArticleCategoriesWithHttpInfo($filters);
        return $response;
    }

    /**
     * Operation getArticleCategoriesWithHttpInfo
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getArticleCategoriesWithHttpInfo(array $filters = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getArticleCategoriesRequest($filters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getArticleCategoriesAsync
     *
     * 
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArticleCategoriesAsync(array $filters = [])
    {
        return $this->getArticleCategoriesAsyncWithHttpInfo($filters)
            ->then(
                function (array $response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getArticleCategoriesAsyncWithHttpInfo
     *
     * 
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArticleCategoriesAsyncWithHttpInfo(array $filters = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getArticleCategoriesRequest($filters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function (ResponseInterface $response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (RequestException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getArticleCategories'
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *
     * @param array $filters API endpoint parameters
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getArticleCategoriesRequest(array $filters = [])
    {
        if (!isset($filters['page'])) {
            $filters['page'] = null;
        }
        if (!isset($filters['count'])) {
            $filters['count'] = null;
        }
        if (!isset($filters['limit'])) {
            $filters['limit'] = null;
        }
        if (!isset($filters['ids'])) {
            $filters['ids'] = null;
        }
        

        $resourcePath = '/article_categories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        
        // query params
        if ($filters['page'] !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($filters['page']);
        }
        // query params
        if ($filters['count'] !== null) {
            $queryParams['count'] = ObjectSerializer::toQueryValue($filters['count']);
        }
        // query params
        if ($filters['limit'] !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($filters['limit']);
        }
        // query params
        if ($filters['ids'] !== null) {
            $queryParams['ids'] = ObjectSerializer::toQueryValue($filters['ids']);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getArticleCategoryById
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getArticleCategoryById($id)
    {
        list($response) = $this->getArticleCategoryByIdWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getArticleCategoryByIdWithHttpInfo
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getArticleCategoryByIdWithHttpInfo($id)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getArticleCategoryByIdRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getArticleCategoryByIdAsync
     *
     * 
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArticleCategoryByIdAsync($id)
    {
        return $this->getArticleCategoryByIdAsyncWithHttpInfo($id)
            ->then(
                function (array $response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getArticleCategoryByIdAsyncWithHttpInfo
     *
     * 
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArticleCategoryByIdAsyncWithHttpInfo($id)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getArticleCategoryByIdRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function (ResponseInterface $response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (RequestException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getArticleCategoryById'
     *
     *
     * @param int $id The id of the resource
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getArticleCategoryByIdRequest($id)
    {
        if (empty($id)) {
            throw new \InvalidArgumentException('Missing parameter "$id" in ContentApi::getArticleCategoryByIdRequest().');
        }
        

        $resourcePath = '/article_categories/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($id !== null) {
            $id = ObjectSerializer::toQueryValue($id);
        }
        

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getArticleCategoryCount
     *
     *
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getArticleCategoryCount()
    {
        list($response) = $this->getArticleCategoryCountWithHttpInfo();
        return $response;
    }

    /**
     * Operation getArticleCategoryCountWithHttpInfo
     *
     *
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getArticleCategoryCountWithHttpInfo()
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getArticleCategoryCountRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getArticleCategoryCountAsync
     *
     * 
     *
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArticleCategoryCountAsync()
    {
        return $this->getArticleCategoryCountAsyncWithHttpInfo()
            ->then(
                function (array $response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getArticleCategoryCountAsyncWithHttpInfo
     *
     * 
     *
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArticleCategoryCountAsyncWithHttpInfo()
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getArticleCategoryCountRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function (ResponseInterface $response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (RequestException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getArticleCategoryCount'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getArticleCategoryCountRequest()
    {
        

        $resourcePath = '/article_categories/counts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getArticleCommentById
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getArticleCommentById($id)
    {
        list($response) = $this->getArticleCommentByIdWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getArticleCommentByIdWithHttpInfo
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getArticleCommentByIdWithHttpInfo($id)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getArticleCommentByIdRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getArticleCommentByIdAsync
     *
     * 
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArticleCommentByIdAsync($id)
    {
        return $this->getArticleCommentByIdAsyncWithHttpInfo($id)
            ->then(
                function (array $response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getArticleCommentByIdAsyncWithHttpInfo
     *
     * 
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArticleCommentByIdAsyncWithHttpInfo($id)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getArticleCommentByIdRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function (ResponseInterface $response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (RequestException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getArticleCommentById'
     *
     *
     * @param int $id The id of the resource
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getArticleCommentByIdRequest($id)
    {
        if (empty($id)) {
            throw new \InvalidArgumentException('Missing parameter "$id" in ContentApi::getArticleCommentByIdRequest().');
        }
        

        $resourcePath = '/article_comments/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($id !== null) {
            $id = ObjectSerializer::toQueryValue($id);
        }
        

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getArticleCommentCount
     *
     * Filters:
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "group_by" string  how to groups comments (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getArticleCommentCount(array $filters = [])
    {
        list($response) = $this->getArticleCommentCountWithHttpInfo($filters);
        return $response;
    }

    /**
     * Operation getArticleCommentCountWithHttpInfo
     *
     * Filters:
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "group_by" string  how to groups comments (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getArticleCommentCountWithHttpInfo(array $filters = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getArticleCommentCountRequest($filters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getArticleCommentCountAsync
     *
     * 
     *
     * Filters:
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "group_by" string  how to groups comments (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArticleCommentCountAsync(array $filters = [])
    {
        return $this->getArticleCommentCountAsyncWithHttpInfo($filters)
            ->then(
                function (array $response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getArticleCommentCountAsyncWithHttpInfo
     *
     * 
     *
     * Filters:
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "group_by" string  how to groups comments (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArticleCommentCountAsyncWithHttpInfo(array $filters = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getArticleCommentCountRequest($filters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function (ResponseInterface $response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (RequestException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getArticleCommentCount'
     *
     * Filters:
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "group_by" string  how to groups comments (optional)
     *
     * @param array $filters API endpoint parameters
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getArticleCommentCountRequest(array $filters = [])
    {
        if (!isset($filters['status'])) {
            $filters['status'] = null;
        }
        if (!isset($filters['is_reviewed'])) {
            $filters['is_reviewed'] = null;
        }
        if (!isset($filters['period_created'])) {
            $filters['period_created'] = null;
        }
        if (!isset($filters['article'])) {
            $filters['article'] = null;
        }
        if (!isset($filters['download'])) {
            $filters['download'] = null;
        }
        if (!isset($filters['news'])) {
            $filters['news'] = null;
        }
        if (!isset($filters['group_by'])) {
            $filters['group_by'] = null;
        }
        

        $resourcePath = '/article_comments/counts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        
        // query params
        if ($filters['status'] !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($filters['status']);
        }
        // query params
        if ($filters['is_reviewed'] !== null) {
            $queryParams['is_reviewed'] = ObjectSerializer::toQueryValue($filters['is_reviewed']);
        }
        // query params
        if ($filters['period_created'] !== null) {
            $queryParams['period_created'] = ObjectSerializer::toQueryValue($filters['period_created']);
        }
        // query params
        if ($filters['article'] !== null) {
            $queryParams['article'] = ObjectSerializer::toQueryValue($filters['article']);
        }
        // query params
        if ($filters['download'] !== null) {
            $queryParams['download'] = ObjectSerializer::toQueryValue($filters['download']);
        }
        // query params
        if ($filters['news'] !== null) {
            $queryParams['news'] = ObjectSerializer::toQueryValue($filters['news']);
        }
        // query params
        if ($filters['group_by'] !== null) {
            $queryParams['group_by'] = ObjectSerializer::toQueryValue($filters['group_by']);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getArticleComments
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "order_by" string  how to order comments (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getArticleComments(array $filters = [])
    {
        list($response) = $this->getArticleCommentsWithHttpInfo($filters);
        return $response;
    }

    /**
     * Operation getArticleCommentsWithHttpInfo
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "order_by" string  how to order comments (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getArticleCommentsWithHttpInfo(array $filters = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getArticleCommentsRequest($filters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getArticleCommentsAsync
     *
     * 
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "order_by" string  how to order comments (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArticleCommentsAsync(array $filters = [])
    {
        return $this->getArticleCommentsAsyncWithHttpInfo($filters)
            ->then(
                function (array $response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getArticleCommentsAsyncWithHttpInfo
     *
     * 
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "order_by" string  how to order comments (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArticleCommentsAsyncWithHttpInfo(array $filters = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getArticleCommentsRequest($filters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function (ResponseInterface $response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (RequestException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getArticleComments'
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "order_by" string  how to order comments (optional)
     *
     * @param array $filters API endpoint parameters
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getArticleCommentsRequest(array $filters = [])
    {
        if (!isset($filters['page'])) {
            $filters['page'] = null;
        }
        if (!isset($filters['count'])) {
            $filters['count'] = null;
        }
        if (!isset($filters['limit'])) {
            $filters['limit'] = null;
        }
        if (!isset($filters['ids'])) {
            $filters['ids'] = null;
        }
        if (!isset($filters['status'])) {
            $filters['status'] = null;
        }
        if (!isset($filters['is_reviewed'])) {
            $filters['is_reviewed'] = null;
        }
        if (!isset($filters['period_created'])) {
            $filters['period_created'] = null;
        }
        if (!isset($filters['article'])) {
            $filters['article'] = null;
        }
        if (!isset($filters['download'])) {
            $filters['download'] = null;
        }
        if (!isset($filters['news'])) {
            $filters['news'] = null;
        }
        if (!isset($filters['order_by'])) {
            $filters['order_by'] = null;
        }
        

        $resourcePath = '/article_comments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        
        // query params
        if ($filters['page'] !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($filters['page']);
        }
        // query params
        if ($filters['count'] !== null) {
            $queryParams['count'] = ObjectSerializer::toQueryValue($filters['count']);
        }
        // query params
        if ($filters['limit'] !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($filters['limit']);
        }
        // query params
        if ($filters['ids'] !== null) {
            $queryParams['ids'] = ObjectSerializer::toQueryValue($filters['ids']);
        }
        // query params
        if ($filters['status'] !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($filters['status']);
        }
        // query params
        if ($filters['is_reviewed'] !== null) {
            $queryParams['is_reviewed'] = ObjectSerializer::toQueryValue($filters['is_reviewed']);
        }
        // query params
        if ($filters['period_created'] !== null) {
            $queryParams['period_created'] = ObjectSerializer::toQueryValue($filters['period_created']);
        }
        // query params
        if ($filters['article'] !== null) {
            $queryParams['article'] = ObjectSerializer::toQueryValue($filters['article']);
        }
        // query params
        if ($filters['download'] !== null) {
            $queryParams['download'] = ObjectSerializer::toQueryValue($filters['download']);
        }
        // query params
        if ($filters['news'] !== null) {
            $queryParams['news'] = ObjectSerializer::toQueryValue($filters['news']);
        }
        // query params
        if ($filters['order_by'] !== null) {
            $queryParams['order_by'] = ObjectSerializer::toQueryValue($filters['order_by']);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getArticleCount
     *
     * Filters:
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group counters (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getArticleCount(array $filters = [])
    {
        list($response) = $this->getArticleCountWithHttpInfo($filters);
        return $response;
    }

    /**
     * Operation getArticleCountWithHttpInfo
     *
     * Filters:
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group counters (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getArticleCountWithHttpInfo(array $filters = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getArticleCountRequest($filters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getArticleCountAsync
     *
     * 
     *
     * Filters:
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group counters (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArticleCountAsync(array $filters = [])
    {
        return $this->getArticleCountAsyncWithHttpInfo($filters)
            ->then(
                function (array $response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getArticleCountAsyncWithHttpInfo
     *
     * 
     *
     * Filters:
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group counters (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArticleCountAsyncWithHttpInfo(array $filters = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getArticleCountRequest($filters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function (ResponseInterface $response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (RequestException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getArticleCount'
     *
     * Filters:
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group counters (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *
     * @param array $filters API endpoint parameters
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getArticleCountRequest(array $filters = [])
    {
        if (!isset($filters['author'])) {
            $filters['author'] = null;
        }
        if (!isset($filters['category'])) {
            $filters['category'] = null;
        }
        if (!isset($filters['group_by'])) {
            $filters['group_by'] = null;
        }
        if (!isset($filters['status'])) {
            $filters['status'] = null;
        }
        if (!isset($filters['hidden_status'])) {
            $filters['hidden_status'] = null;
        }
        if (!isset($filters['period_created'])) {
            $filters['period_created'] = null;
        }
        if (!isset($filters['period_last_comment'])) {
            $filters['period_last_comment'] = null;
        }
        if (!isset($filters['period_published'])) {
            $filters['period_published'] = null;
        }
        if (!isset($filters['period_updated'])) {
            $filters['period_updated'] = null;
        }
        

        $resourcePath = '/articles/counts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        
        // query params
        if ($filters['author'] !== null) {
            $queryParams['author'] = ObjectSerializer::toQueryValue($filters['author']);
        }
        // query params
        if ($filters['category'] !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($filters['category']);
        }
        // query params
        if ($filters['group_by'] !== null) {
            $queryParams['group_by'] = ObjectSerializer::toQueryValue($filters['group_by']);
        }
        // query params
        if ($filters['status'] !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($filters['status']);
        }
        // query params
        if ($filters['hidden_status'] !== null) {
            $queryParams['hidden_status'] = ObjectSerializer::toQueryValue($filters['hidden_status']);
        }
        // query params
        if ($filters['period_created'] !== null) {
            $queryParams['period_created'] = ObjectSerializer::toQueryValue($filters['period_created']);
        }
        // query params
        if ($filters['period_last_comment'] !== null) {
            $queryParams['period_last_comment'] = ObjectSerializer::toQueryValue($filters['period_last_comment']);
        }
        // query params
        if ($filters['period_published'] !== null) {
            $queryParams['period_published'] = ObjectSerializer::toQueryValue($filters['period_published']);
        }
        // query params
        if ($filters['period_updated'] !== null) {
            $queryParams['period_updated'] = ObjectSerializer::toQueryValue($filters['period_updated']);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getArticlePendingCreateById
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getArticlePendingCreateById($id)
    {
        list($response) = $this->getArticlePendingCreateByIdWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getArticlePendingCreateByIdWithHttpInfo
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getArticlePendingCreateByIdWithHttpInfo($id)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getArticlePendingCreateByIdRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getArticlePendingCreateByIdAsync
     *
     * 
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArticlePendingCreateByIdAsync($id)
    {
        return $this->getArticlePendingCreateByIdAsyncWithHttpInfo($id)
            ->then(
                function (array $response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getArticlePendingCreateByIdAsyncWithHttpInfo
     *
     * 
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArticlePendingCreateByIdAsyncWithHttpInfo($id)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getArticlePendingCreateByIdRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function (ResponseInterface $response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (RequestException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getArticlePendingCreateById'
     *
     *
     * @param int $id The id of the resource
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getArticlePendingCreateByIdRequest($id)
    {
        if (empty($id)) {
            throw new \InvalidArgumentException('Missing parameter "$id" in ContentApi::getArticlePendingCreateByIdRequest().');
        }
        

        $resourcePath = '/article_pending_creates/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($id !== null) {
            $id = ObjectSerializer::toQueryValue($id);
        }
        

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getArticlePendingCreateCount
     *
     * Filters:
     *   "assigned_person" string   (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getArticlePendingCreateCount(array $filters = [])
    {
        list($response) = $this->getArticlePendingCreateCountWithHttpInfo($filters);
        return $response;
    }

    /**
     * Operation getArticlePendingCreateCountWithHttpInfo
     *
     * Filters:
     *   "assigned_person" string   (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getArticlePendingCreateCountWithHttpInfo(array $filters = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getArticlePendingCreateCountRequest($filters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getArticlePendingCreateCountAsync
     *
     * 
     *
     * Filters:
     *   "assigned_person" string   (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArticlePendingCreateCountAsync(array $filters = [])
    {
        return $this->getArticlePendingCreateCountAsyncWithHttpInfo($filters)
            ->then(
                function (array $response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getArticlePendingCreateCountAsyncWithHttpInfo
     *
     * 
     *
     * Filters:
     *   "assigned_person" string   (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArticlePendingCreateCountAsyncWithHttpInfo(array $filters = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getArticlePendingCreateCountRequest($filters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function (ResponseInterface $response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (RequestException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getArticlePendingCreateCount'
     *
     * Filters:
     *   "assigned_person" string   (optional)
     *
     * @param array $filters API endpoint parameters
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getArticlePendingCreateCountRequest(array $filters = [])
    {
        if (!isset($filters['assigned_person'])) {
            $filters['assigned_person'] = null;
        }
        

        $resourcePath = '/article_pending_creates/counts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        
        // query params
        if ($filters['assigned_person'] !== null) {
            $queryParams['assigned_person'] = ObjectSerializer::toQueryValue($filters['assigned_person']);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getArticlePendingCreates
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "assigned_person" string   (optional)
     *   "order_by" string  how to order result (optional)
     *   "order_dir" string  order direction (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getArticlePendingCreates(array $filters = [])
    {
        list($response) = $this->getArticlePendingCreatesWithHttpInfo($filters);
        return $response;
    }

    /**
     * Operation getArticlePendingCreatesWithHttpInfo
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "assigned_person" string   (optional)
     *   "order_by" string  how to order result (optional)
     *   "order_dir" string  order direction (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getArticlePendingCreatesWithHttpInfo(array $filters = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getArticlePendingCreatesRequest($filters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getArticlePendingCreatesAsync
     *
     * 
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "assigned_person" string   (optional)
     *   "order_by" string  how to order result (optional)
     *   "order_dir" string  order direction (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArticlePendingCreatesAsync(array $filters = [])
    {
        return $this->getArticlePendingCreatesAsyncWithHttpInfo($filters)
            ->then(
                function (array $response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getArticlePendingCreatesAsyncWithHttpInfo
     *
     * 
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "assigned_person" string   (optional)
     *   "order_by" string  how to order result (optional)
     *   "order_dir" string  order direction (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArticlePendingCreatesAsyncWithHttpInfo(array $filters = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getArticlePendingCreatesRequest($filters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function (ResponseInterface $response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (RequestException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getArticlePendingCreates'
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "assigned_person" string   (optional)
     *   "order_by" string  how to order result (optional)
     *   "order_dir" string  order direction (optional)
     *
     * @param array $filters API endpoint parameters
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getArticlePendingCreatesRequest(array $filters = [])
    {
        if (!isset($filters['page'])) {
            $filters['page'] = null;
        }
        if (!isset($filters['count'])) {
            $filters['count'] = null;
        }
        if (!isset($filters['limit'])) {
            $filters['limit'] = null;
        }
        if (!isset($filters['ids'])) {
            $filters['ids'] = null;
        }
        if (!isset($filters['assigned_person'])) {
            $filters['assigned_person'] = null;
        }
        if (!isset($filters['order_by'])) {
            $filters['order_by'] = null;
        }
        if (!isset($filters['order_dir'])) {
            $filters['order_dir'] = null;
        }
        

        $resourcePath = '/article_pending_creates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        
        // query params
        if ($filters['page'] !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($filters['page']);
        }
        // query params
        if ($filters['count'] !== null) {
            $queryParams['count'] = ObjectSerializer::toQueryValue($filters['count']);
        }
        // query params
        if ($filters['limit'] !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($filters['limit']);
        }
        // query params
        if ($filters['ids'] !== null) {
            $queryParams['ids'] = ObjectSerializer::toQueryValue($filters['ids']);
        }
        // query params
        if ($filters['assigned_person'] !== null) {
            $queryParams['assigned_person'] = ObjectSerializer::toQueryValue($filters['assigned_person']);
        }
        // query params
        if ($filters['order_by'] !== null) {
            $queryParams['order_by'] = ObjectSerializer::toQueryValue($filters['order_by']);
        }
        // query params
        if ($filters['order_dir'] !== null) {
            $queryParams['order_dir'] = ObjectSerializer::toQueryValue($filters['order_dir']);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getArticles
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group downloads (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *   "order_by" int  how to order (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getArticles(array $filters = [])
    {
        list($response) = $this->getArticlesWithHttpInfo($filters);
        return $response;
    }

    /**
     * Operation getArticlesWithHttpInfo
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group downloads (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *   "order_by" int  how to order (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getArticlesWithHttpInfo(array $filters = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getArticlesRequest($filters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getArticlesAsync
     *
     * 
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group downloads (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *   "order_by" int  how to order (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArticlesAsync(array $filters = [])
    {
        return $this->getArticlesAsyncWithHttpInfo($filters)
            ->then(
                function (array $response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getArticlesAsyncWithHttpInfo
     *
     * 
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group downloads (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *   "order_by" int  how to order (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArticlesAsyncWithHttpInfo(array $filters = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getArticlesRequest($filters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function (ResponseInterface $response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (RequestException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getArticles'
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group downloads (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *   "order_by" int  how to order (optional)
     *
     * @param array $filters API endpoint parameters
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getArticlesRequest(array $filters = [])
    {
        if (!isset($filters['page'])) {
            $filters['page'] = null;
        }
        if (!isset($filters['count'])) {
            $filters['count'] = null;
        }
        if (!isset($filters['limit'])) {
            $filters['limit'] = null;
        }
        if (!isset($filters['ids'])) {
            $filters['ids'] = null;
        }
        if (!isset($filters['author'])) {
            $filters['author'] = null;
        }
        if (!isset($filters['category'])) {
            $filters['category'] = null;
        }
        if (!isset($filters['group_by'])) {
            $filters['group_by'] = null;
        }
        if (!isset($filters['status'])) {
            $filters['status'] = null;
        }
        if (!isset($filters['hidden_status'])) {
            $filters['hidden_status'] = null;
        }
        if (!isset($filters['period_created'])) {
            $filters['period_created'] = null;
        }
        if (!isset($filters['period_last_comment'])) {
            $filters['period_last_comment'] = null;
        }
        if (!isset($filters['period_published'])) {
            $filters['period_published'] = null;
        }
        if (!isset($filters['period_updated'])) {
            $filters['period_updated'] = null;
        }
        if (!isset($filters['order_by'])) {
            $filters['order_by'] = null;
        }
        

        $resourcePath = '/articles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        
        // query params
        if ($filters['page'] !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($filters['page']);
        }
        // query params
        if ($filters['count'] !== null) {
            $queryParams['count'] = ObjectSerializer::toQueryValue($filters['count']);
        }
        // query params
        if ($filters['limit'] !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($filters['limit']);
        }
        // query params
        if ($filters['ids'] !== null) {
            $queryParams['ids'] = ObjectSerializer::toQueryValue($filters['ids']);
        }
        // query params
        if ($filters['author'] !== null) {
            $queryParams['author'] = ObjectSerializer::toQueryValue($filters['author']);
        }
        // query params
        if ($filters['category'] !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($filters['category']);
        }
        // query params
        if ($filters['group_by'] !== null) {
            $queryParams['group_by'] = ObjectSerializer::toQueryValue($filters['group_by']);
        }
        // query params
        if ($filters['status'] !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($filters['status']);
        }
        // query params
        if ($filters['hidden_status'] !== null) {
            $queryParams['hidden_status'] = ObjectSerializer::toQueryValue($filters['hidden_status']);
        }
        // query params
        if ($filters['period_created'] !== null) {
            $queryParams['period_created'] = ObjectSerializer::toQueryValue($filters['period_created']);
        }
        // query params
        if ($filters['period_last_comment'] !== null) {
            $queryParams['period_last_comment'] = ObjectSerializer::toQueryValue($filters['period_last_comment']);
        }
        // query params
        if ($filters['period_published'] !== null) {
            $queryParams['period_published'] = ObjectSerializer::toQueryValue($filters['period_published']);
        }
        // query params
        if ($filters['period_updated'] !== null) {
            $queryParams['period_updated'] = ObjectSerializer::toQueryValue($filters['period_updated']);
        }
        // query params
        if ($filters['order_by'] !== null) {
            $queryParams['order_by'] = ObjectSerializer::toQueryValue($filters['order_by']);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getContentCategories
     *
     *
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getContentCategories()
    {
        list($response) = $this->getContentCategoriesWithHttpInfo();
        return $response;
    }

    /**
     * Operation getContentCategoriesWithHttpInfo
     *
     *
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getContentCategoriesWithHttpInfo()
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getContentCategoriesRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getContentCategoriesAsync
     *
     * 
     *
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getContentCategoriesAsync()
    {
        return $this->getContentCategoriesAsyncWithHttpInfo()
            ->then(
                function (array $response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getContentCategoriesAsyncWithHttpInfo
     *
     * 
     *
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getContentCategoriesAsyncWithHttpInfo()
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getContentCategoriesRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function (ResponseInterface $response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (RequestException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getContentCategories'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getContentCategoriesRequest()
    {
        

        $resourcePath = '/content_categories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDownloadById
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getDownloadById($id)
    {
        list($response) = $this->getDownloadByIdWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getDownloadByIdWithHttpInfo
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDownloadByIdWithHttpInfo($id)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getDownloadByIdRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDownloadByIdAsync
     *
     * 
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDownloadByIdAsync($id)
    {
        return $this->getDownloadByIdAsyncWithHttpInfo($id)
            ->then(
                function (array $response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDownloadByIdAsyncWithHttpInfo
     *
     * 
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDownloadByIdAsyncWithHttpInfo($id)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getDownloadByIdRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function (ResponseInterface $response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (RequestException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDownloadById'
     *
     *
     * @param int $id The id of the resource
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDownloadByIdRequest($id)
    {
        if (empty($id)) {
            throw new \InvalidArgumentException('Missing parameter "$id" in ContentApi::getDownloadByIdRequest().');
        }
        

        $resourcePath = '/downloads/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($id !== null) {
            $id = ObjectSerializer::toQueryValue($id);
        }
        

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDownloadCategories
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getDownloadCategories(array $filters = [])
    {
        list($response) = $this->getDownloadCategoriesWithHttpInfo($filters);
        return $response;
    }

    /**
     * Operation getDownloadCategoriesWithHttpInfo
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDownloadCategoriesWithHttpInfo(array $filters = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getDownloadCategoriesRequest($filters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDownloadCategoriesAsync
     *
     * 
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDownloadCategoriesAsync(array $filters = [])
    {
        return $this->getDownloadCategoriesAsyncWithHttpInfo($filters)
            ->then(
                function (array $response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDownloadCategoriesAsyncWithHttpInfo
     *
     * 
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDownloadCategoriesAsyncWithHttpInfo(array $filters = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getDownloadCategoriesRequest($filters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function (ResponseInterface $response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (RequestException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDownloadCategories'
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *
     * @param array $filters API endpoint parameters
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDownloadCategoriesRequest(array $filters = [])
    {
        if (!isset($filters['page'])) {
            $filters['page'] = null;
        }
        if (!isset($filters['count'])) {
            $filters['count'] = null;
        }
        if (!isset($filters['limit'])) {
            $filters['limit'] = null;
        }
        if (!isset($filters['ids'])) {
            $filters['ids'] = null;
        }
        

        $resourcePath = '/download_categories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        
        // query params
        if ($filters['page'] !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($filters['page']);
        }
        // query params
        if ($filters['count'] !== null) {
            $queryParams['count'] = ObjectSerializer::toQueryValue($filters['count']);
        }
        // query params
        if ($filters['limit'] !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($filters['limit']);
        }
        // query params
        if ($filters['ids'] !== null) {
            $queryParams['ids'] = ObjectSerializer::toQueryValue($filters['ids']);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDownloadCategoryById
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getDownloadCategoryById($id)
    {
        list($response) = $this->getDownloadCategoryByIdWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getDownloadCategoryByIdWithHttpInfo
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDownloadCategoryByIdWithHttpInfo($id)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getDownloadCategoryByIdRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDownloadCategoryByIdAsync
     *
     * 
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDownloadCategoryByIdAsync($id)
    {
        return $this->getDownloadCategoryByIdAsyncWithHttpInfo($id)
            ->then(
                function (array $response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDownloadCategoryByIdAsyncWithHttpInfo
     *
     * 
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDownloadCategoryByIdAsyncWithHttpInfo($id)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getDownloadCategoryByIdRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function (ResponseInterface $response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (RequestException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDownloadCategoryById'
     *
     *
     * @param int $id The id of the resource
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDownloadCategoryByIdRequest($id)
    {
        if (empty($id)) {
            throw new \InvalidArgumentException('Missing parameter "$id" in ContentApi::getDownloadCategoryByIdRequest().');
        }
        

        $resourcePath = '/download_categories/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($id !== null) {
            $id = ObjectSerializer::toQueryValue($id);
        }
        

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDownloadCategoryCount
     *
     *
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getDownloadCategoryCount()
    {
        list($response) = $this->getDownloadCategoryCountWithHttpInfo();
        return $response;
    }

    /**
     * Operation getDownloadCategoryCountWithHttpInfo
     *
     *
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDownloadCategoryCountWithHttpInfo()
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getDownloadCategoryCountRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDownloadCategoryCountAsync
     *
     * 
     *
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDownloadCategoryCountAsync()
    {
        return $this->getDownloadCategoryCountAsyncWithHttpInfo()
            ->then(
                function (array $response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDownloadCategoryCountAsyncWithHttpInfo
     *
     * 
     *
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDownloadCategoryCountAsyncWithHttpInfo()
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getDownloadCategoryCountRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function (ResponseInterface $response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (RequestException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDownloadCategoryCount'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDownloadCategoryCountRequest()
    {
        

        $resourcePath = '/download_categories/counts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDownloadCommentById
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getDownloadCommentById($id)
    {
        list($response) = $this->getDownloadCommentByIdWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getDownloadCommentByIdWithHttpInfo
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDownloadCommentByIdWithHttpInfo($id)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getDownloadCommentByIdRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDownloadCommentByIdAsync
     *
     * 
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDownloadCommentByIdAsync($id)
    {
        return $this->getDownloadCommentByIdAsyncWithHttpInfo($id)
            ->then(
                function (array $response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDownloadCommentByIdAsyncWithHttpInfo
     *
     * 
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDownloadCommentByIdAsyncWithHttpInfo($id)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getDownloadCommentByIdRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function (ResponseInterface $response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (RequestException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDownloadCommentById'
     *
     *
     * @param int $id The id of the resource
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDownloadCommentByIdRequest($id)
    {
        if (empty($id)) {
            throw new \InvalidArgumentException('Missing parameter "$id" in ContentApi::getDownloadCommentByIdRequest().');
        }
        

        $resourcePath = '/download_comments/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($id !== null) {
            $id = ObjectSerializer::toQueryValue($id);
        }
        

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDownloadCommentCount
     *
     * Filters:
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "group_by" string  how to groups comments (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getDownloadCommentCount(array $filters = [])
    {
        list($response) = $this->getDownloadCommentCountWithHttpInfo($filters);
        return $response;
    }

    /**
     * Operation getDownloadCommentCountWithHttpInfo
     *
     * Filters:
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "group_by" string  how to groups comments (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDownloadCommentCountWithHttpInfo(array $filters = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getDownloadCommentCountRequest($filters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDownloadCommentCountAsync
     *
     * 
     *
     * Filters:
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "group_by" string  how to groups comments (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDownloadCommentCountAsync(array $filters = [])
    {
        return $this->getDownloadCommentCountAsyncWithHttpInfo($filters)
            ->then(
                function (array $response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDownloadCommentCountAsyncWithHttpInfo
     *
     * 
     *
     * Filters:
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "group_by" string  how to groups comments (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDownloadCommentCountAsyncWithHttpInfo(array $filters = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getDownloadCommentCountRequest($filters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function (ResponseInterface $response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (RequestException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDownloadCommentCount'
     *
     * Filters:
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "group_by" string  how to groups comments (optional)
     *
     * @param array $filters API endpoint parameters
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDownloadCommentCountRequest(array $filters = [])
    {
        if (!isset($filters['status'])) {
            $filters['status'] = null;
        }
        if (!isset($filters['is_reviewed'])) {
            $filters['is_reviewed'] = null;
        }
        if (!isset($filters['period_created'])) {
            $filters['period_created'] = null;
        }
        if (!isset($filters['article'])) {
            $filters['article'] = null;
        }
        if (!isset($filters['download'])) {
            $filters['download'] = null;
        }
        if (!isset($filters['news'])) {
            $filters['news'] = null;
        }
        if (!isset($filters['group_by'])) {
            $filters['group_by'] = null;
        }
        

        $resourcePath = '/download_comments/counts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        
        // query params
        if ($filters['status'] !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($filters['status']);
        }
        // query params
        if ($filters['is_reviewed'] !== null) {
            $queryParams['is_reviewed'] = ObjectSerializer::toQueryValue($filters['is_reviewed']);
        }
        // query params
        if ($filters['period_created'] !== null) {
            $queryParams['period_created'] = ObjectSerializer::toQueryValue($filters['period_created']);
        }
        // query params
        if ($filters['article'] !== null) {
            $queryParams['article'] = ObjectSerializer::toQueryValue($filters['article']);
        }
        // query params
        if ($filters['download'] !== null) {
            $queryParams['download'] = ObjectSerializer::toQueryValue($filters['download']);
        }
        // query params
        if ($filters['news'] !== null) {
            $queryParams['news'] = ObjectSerializer::toQueryValue($filters['news']);
        }
        // query params
        if ($filters['group_by'] !== null) {
            $queryParams['group_by'] = ObjectSerializer::toQueryValue($filters['group_by']);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDownloadComments
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "order_by" string  how to order comments (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getDownloadComments(array $filters = [])
    {
        list($response) = $this->getDownloadCommentsWithHttpInfo($filters);
        return $response;
    }

    /**
     * Operation getDownloadCommentsWithHttpInfo
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "order_by" string  how to order comments (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDownloadCommentsWithHttpInfo(array $filters = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getDownloadCommentsRequest($filters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDownloadCommentsAsync
     *
     * 
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "order_by" string  how to order comments (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDownloadCommentsAsync(array $filters = [])
    {
        return $this->getDownloadCommentsAsyncWithHttpInfo($filters)
            ->then(
                function (array $response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDownloadCommentsAsyncWithHttpInfo
     *
     * 
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "order_by" string  how to order comments (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDownloadCommentsAsyncWithHttpInfo(array $filters = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getDownloadCommentsRequest($filters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function (ResponseInterface $response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (RequestException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDownloadComments'
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "order_by" string  how to order comments (optional)
     *
     * @param array $filters API endpoint parameters
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDownloadCommentsRequest(array $filters = [])
    {
        if (!isset($filters['page'])) {
            $filters['page'] = null;
        }
        if (!isset($filters['count'])) {
            $filters['count'] = null;
        }
        if (!isset($filters['limit'])) {
            $filters['limit'] = null;
        }
        if (!isset($filters['ids'])) {
            $filters['ids'] = null;
        }
        if (!isset($filters['status'])) {
            $filters['status'] = null;
        }
        if (!isset($filters['is_reviewed'])) {
            $filters['is_reviewed'] = null;
        }
        if (!isset($filters['period_created'])) {
            $filters['period_created'] = null;
        }
        if (!isset($filters['article'])) {
            $filters['article'] = null;
        }
        if (!isset($filters['download'])) {
            $filters['download'] = null;
        }
        if (!isset($filters['news'])) {
            $filters['news'] = null;
        }
        if (!isset($filters['order_by'])) {
            $filters['order_by'] = null;
        }
        

        $resourcePath = '/download_comments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        
        // query params
        if ($filters['page'] !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($filters['page']);
        }
        // query params
        if ($filters['count'] !== null) {
            $queryParams['count'] = ObjectSerializer::toQueryValue($filters['count']);
        }
        // query params
        if ($filters['limit'] !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($filters['limit']);
        }
        // query params
        if ($filters['ids'] !== null) {
            $queryParams['ids'] = ObjectSerializer::toQueryValue($filters['ids']);
        }
        // query params
        if ($filters['status'] !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($filters['status']);
        }
        // query params
        if ($filters['is_reviewed'] !== null) {
            $queryParams['is_reviewed'] = ObjectSerializer::toQueryValue($filters['is_reviewed']);
        }
        // query params
        if ($filters['period_created'] !== null) {
            $queryParams['period_created'] = ObjectSerializer::toQueryValue($filters['period_created']);
        }
        // query params
        if ($filters['article'] !== null) {
            $queryParams['article'] = ObjectSerializer::toQueryValue($filters['article']);
        }
        // query params
        if ($filters['download'] !== null) {
            $queryParams['download'] = ObjectSerializer::toQueryValue($filters['download']);
        }
        // query params
        if ($filters['news'] !== null) {
            $queryParams['news'] = ObjectSerializer::toQueryValue($filters['news']);
        }
        // query params
        if ($filters['order_by'] !== null) {
            $queryParams['order_by'] = ObjectSerializer::toQueryValue($filters['order_by']);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDownloadCount
     *
     * Filters:
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group counters (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getDownloadCount(array $filters = [])
    {
        list($response) = $this->getDownloadCountWithHttpInfo($filters);
        return $response;
    }

    /**
     * Operation getDownloadCountWithHttpInfo
     *
     * Filters:
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group counters (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDownloadCountWithHttpInfo(array $filters = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getDownloadCountRequest($filters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDownloadCountAsync
     *
     * 
     *
     * Filters:
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group counters (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDownloadCountAsync(array $filters = [])
    {
        return $this->getDownloadCountAsyncWithHttpInfo($filters)
            ->then(
                function (array $response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDownloadCountAsyncWithHttpInfo
     *
     * 
     *
     * Filters:
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group counters (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDownloadCountAsyncWithHttpInfo(array $filters = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getDownloadCountRequest($filters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function (ResponseInterface $response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (RequestException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDownloadCount'
     *
     * Filters:
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group counters (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *
     * @param array $filters API endpoint parameters
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDownloadCountRequest(array $filters = [])
    {
        if (!isset($filters['author'])) {
            $filters['author'] = null;
        }
        if (!isset($filters['category'])) {
            $filters['category'] = null;
        }
        if (!isset($filters['group_by'])) {
            $filters['group_by'] = null;
        }
        if (!isset($filters['status'])) {
            $filters['status'] = null;
        }
        if (!isset($filters['hidden_status'])) {
            $filters['hidden_status'] = null;
        }
        if (!isset($filters['period_created'])) {
            $filters['period_created'] = null;
        }
        if (!isset($filters['period_last_comment'])) {
            $filters['period_last_comment'] = null;
        }
        if (!isset($filters['period_published'])) {
            $filters['period_published'] = null;
        }
        if (!isset($filters['period_updated'])) {
            $filters['period_updated'] = null;
        }
        

        $resourcePath = '/downloads/counts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        
        // query params
        if ($filters['author'] !== null) {
            $queryParams['author'] = ObjectSerializer::toQueryValue($filters['author']);
        }
        // query params
        if ($filters['category'] !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($filters['category']);
        }
        // query params
        if ($filters['group_by'] !== null) {
            $queryParams['group_by'] = ObjectSerializer::toQueryValue($filters['group_by']);
        }
        // query params
        if ($filters['status'] !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($filters['status']);
        }
        // query params
        if ($filters['hidden_status'] !== null) {
            $queryParams['hidden_status'] = ObjectSerializer::toQueryValue($filters['hidden_status']);
        }
        // query params
        if ($filters['period_created'] !== null) {
            $queryParams['period_created'] = ObjectSerializer::toQueryValue($filters['period_created']);
        }
        // query params
        if ($filters['period_last_comment'] !== null) {
            $queryParams['period_last_comment'] = ObjectSerializer::toQueryValue($filters['period_last_comment']);
        }
        // query params
        if ($filters['period_published'] !== null) {
            $queryParams['period_published'] = ObjectSerializer::toQueryValue($filters['period_published']);
        }
        // query params
        if ($filters['period_updated'] !== null) {
            $queryParams['period_updated'] = ObjectSerializer::toQueryValue($filters['period_updated']);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDownloads
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group downloads (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *   "order_by" int  how to order (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getDownloads(array $filters = [])
    {
        list($response) = $this->getDownloadsWithHttpInfo($filters);
        return $response;
    }

    /**
     * Operation getDownloadsWithHttpInfo
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group downloads (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *   "order_by" int  how to order (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDownloadsWithHttpInfo(array $filters = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getDownloadsRequest($filters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDownloadsAsync
     *
     * 
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group downloads (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *   "order_by" int  how to order (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDownloadsAsync(array $filters = [])
    {
        return $this->getDownloadsAsyncWithHttpInfo($filters)
            ->then(
                function (array $response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDownloadsAsyncWithHttpInfo
     *
     * 
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group downloads (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *   "order_by" int  how to order (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDownloadsAsyncWithHttpInfo(array $filters = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getDownloadsRequest($filters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function (ResponseInterface $response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (RequestException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDownloads'
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group downloads (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *   "order_by" int  how to order (optional)
     *
     * @param array $filters API endpoint parameters
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDownloadsRequest(array $filters = [])
    {
        if (!isset($filters['page'])) {
            $filters['page'] = null;
        }
        if (!isset($filters['count'])) {
            $filters['count'] = null;
        }
        if (!isset($filters['limit'])) {
            $filters['limit'] = null;
        }
        if (!isset($filters['ids'])) {
            $filters['ids'] = null;
        }
        if (!isset($filters['author'])) {
            $filters['author'] = null;
        }
        if (!isset($filters['category'])) {
            $filters['category'] = null;
        }
        if (!isset($filters['group_by'])) {
            $filters['group_by'] = null;
        }
        if (!isset($filters['status'])) {
            $filters['status'] = null;
        }
        if (!isset($filters['hidden_status'])) {
            $filters['hidden_status'] = null;
        }
        if (!isset($filters['period_created'])) {
            $filters['period_created'] = null;
        }
        if (!isset($filters['period_last_comment'])) {
            $filters['period_last_comment'] = null;
        }
        if (!isset($filters['period_published'])) {
            $filters['period_published'] = null;
        }
        if (!isset($filters['period_updated'])) {
            $filters['period_updated'] = null;
        }
        if (!isset($filters['order_by'])) {
            $filters['order_by'] = null;
        }
        

        $resourcePath = '/downloads';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        
        // query params
        if ($filters['page'] !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($filters['page']);
        }
        // query params
        if ($filters['count'] !== null) {
            $queryParams['count'] = ObjectSerializer::toQueryValue($filters['count']);
        }
        // query params
        if ($filters['limit'] !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($filters['limit']);
        }
        // query params
        if ($filters['ids'] !== null) {
            $queryParams['ids'] = ObjectSerializer::toQueryValue($filters['ids']);
        }
        // query params
        if ($filters['author'] !== null) {
            $queryParams['author'] = ObjectSerializer::toQueryValue($filters['author']);
        }
        // query params
        if ($filters['category'] !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($filters['category']);
        }
        // query params
        if ($filters['group_by'] !== null) {
            $queryParams['group_by'] = ObjectSerializer::toQueryValue($filters['group_by']);
        }
        // query params
        if ($filters['status'] !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($filters['status']);
        }
        // query params
        if ($filters['hidden_status'] !== null) {
            $queryParams['hidden_status'] = ObjectSerializer::toQueryValue($filters['hidden_status']);
        }
        // query params
        if ($filters['period_created'] !== null) {
            $queryParams['period_created'] = ObjectSerializer::toQueryValue($filters['period_created']);
        }
        // query params
        if ($filters['period_last_comment'] !== null) {
            $queryParams['period_last_comment'] = ObjectSerializer::toQueryValue($filters['period_last_comment']);
        }
        // query params
        if ($filters['period_published'] !== null) {
            $queryParams['period_published'] = ObjectSerializer::toQueryValue($filters['period_published']);
        }
        // query params
        if ($filters['period_updated'] !== null) {
            $queryParams['period_updated'] = ObjectSerializer::toQueryValue($filters['period_updated']);
        }
        // query params
        if ($filters['order_by'] !== null) {
            $queryParams['order_by'] = ObjectSerializer::toQueryValue($filters['order_by']);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGuideByGuideIdExport
     *
     *
     * @param string $guide_id 
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getGuideByGuideIdExport($guide_id)
    {
        list($response) = $this->getGuideByGuideIdExportWithHttpInfo($guide_id);
        return $response;
    }

    /**
     * Operation getGuideByGuideIdExportWithHttpInfo
     *
     *
     * @param string $guide_id 
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGuideByGuideIdExportWithHttpInfo($guide_id)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getGuideByGuideIdExportRequest($guide_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getGuideByGuideIdExportAsync
     *
     * 
     *
     *
     * @param string $guide_id 
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGuideByGuideIdExportAsync($guide_id)
    {
        return $this->getGuideByGuideIdExportAsyncWithHttpInfo($guide_id)
            ->then(
                function (array $response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGuideByGuideIdExportAsyncWithHttpInfo
     *
     * 
     *
     *
     * @param string $guide_id 
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGuideByGuideIdExportAsyncWithHttpInfo($guide_id)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getGuideByGuideIdExportRequest($guide_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function (ResponseInterface $response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (RequestException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGuideByGuideIdExport'
     *
     *
     * @param string $guide_id 
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getGuideByGuideIdExportRequest($guide_id)
    {
        if (empty($guide_id)) {
            throw new \InvalidArgumentException('Missing parameter "$guide_id" in ContentApi::getGuideByGuideIdExportRequest().');
        }
        

        $resourcePath = '/guides/{guideId}/export';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($guide_id !== null) {
            $guide_id = ObjectSerializer::toQueryValue($guide_id);
        }
        

        // path params
        if ($guide_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guideId' . '}',
                ObjectSerializer::toPathValue($guide_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGuideByGuideIdTree
     *
     *
     * @param string $guide_id 
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getGuideByGuideIdTree($guide_id)
    {
        list($response) = $this->getGuideByGuideIdTreeWithHttpInfo($guide_id);
        return $response;
    }

    /**
     * Operation getGuideByGuideIdTreeWithHttpInfo
     *
     *
     * @param string $guide_id 
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGuideByGuideIdTreeWithHttpInfo($guide_id)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getGuideByGuideIdTreeRequest($guide_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getGuideByGuideIdTreeAsync
     *
     * 
     *
     *
     * @param string $guide_id 
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGuideByGuideIdTreeAsync($guide_id)
    {
        return $this->getGuideByGuideIdTreeAsyncWithHttpInfo($guide_id)
            ->then(
                function (array $response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGuideByGuideIdTreeAsyncWithHttpInfo
     *
     * 
     *
     *
     * @param string $guide_id 
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGuideByGuideIdTreeAsyncWithHttpInfo($guide_id)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getGuideByGuideIdTreeRequest($guide_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function (ResponseInterface $response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (RequestException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGuideByGuideIdTree'
     *
     *
     * @param string $guide_id 
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getGuideByGuideIdTreeRequest($guide_id)
    {
        if (empty($guide_id)) {
            throw new \InvalidArgumentException('Missing parameter "$guide_id" in ContentApi::getGuideByGuideIdTreeRequest().');
        }
        

        $resourcePath = '/guides/{guideId}/tree';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($guide_id !== null) {
            $guide_id = ObjectSerializer::toQueryValue($guide_id);
        }
        

        // path params
        if ($guide_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guideId' . '}',
                ObjectSerializer::toPathValue($guide_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGuideById
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getGuideById($id)
    {
        list($response) = $this->getGuideByIdWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getGuideByIdWithHttpInfo
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGuideByIdWithHttpInfo($id)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getGuideByIdRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getGuideByIdAsync
     *
     * 
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGuideByIdAsync($id)
    {
        return $this->getGuideByIdAsyncWithHttpInfo($id)
            ->then(
                function (array $response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGuideByIdAsyncWithHttpInfo
     *
     * 
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGuideByIdAsyncWithHttpInfo($id)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getGuideByIdRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function (ResponseInterface $response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (RequestException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGuideById'
     *
     *
     * @param int $id The id of the resource
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getGuideByIdRequest($id)
    {
        if (empty($id)) {
            throw new \InvalidArgumentException('Missing parameter "$id" in ContentApi::getGuideByIdRequest().');
        }
        

        $resourcePath = '/guides/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($id !== null) {
            $id = ObjectSerializer::toQueryValue($id);
        }
        

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGuideCount
     *
     *
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getGuideCount()
    {
        list($response) = $this->getGuideCountWithHttpInfo();
        return $response;
    }

    /**
     * Operation getGuideCountWithHttpInfo
     *
     *
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGuideCountWithHttpInfo()
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getGuideCountRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getGuideCountAsync
     *
     * 
     *
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGuideCountAsync()
    {
        return $this->getGuideCountAsyncWithHttpInfo()
            ->then(
                function (array $response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGuideCountAsyncWithHttpInfo
     *
     * 
     *
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGuideCountAsyncWithHttpInfo()
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getGuideCountRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function (ResponseInterface $response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (RequestException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGuideCount'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getGuideCountRequest()
    {
        

        $resourcePath = '/guides/counts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGuides
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getGuides(array $filters = [])
    {
        list($response) = $this->getGuidesWithHttpInfo($filters);
        return $response;
    }

    /**
     * Operation getGuidesWithHttpInfo
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGuidesWithHttpInfo(array $filters = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getGuidesRequest($filters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getGuidesAsync
     *
     * 
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGuidesAsync(array $filters = [])
    {
        return $this->getGuidesAsyncWithHttpInfo($filters)
            ->then(
                function (array $response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGuidesAsyncWithHttpInfo
     *
     * 
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGuidesAsyncWithHttpInfo(array $filters = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getGuidesRequest($filters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function (ResponseInterface $response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (RequestException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGuides'
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *
     * @param array $filters API endpoint parameters
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getGuidesRequest(array $filters = [])
    {
        if (!isset($filters['page'])) {
            $filters['page'] = null;
        }
        if (!isset($filters['count'])) {
            $filters['count'] = null;
        }
        if (!isset($filters['limit'])) {
            $filters['limit'] = null;
        }
        if (!isset($filters['ids'])) {
            $filters['ids'] = null;
        }
        

        $resourcePath = '/guides';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        
        // query params
        if ($filters['page'] !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($filters['page']);
        }
        // query params
        if ($filters['count'] !== null) {
            $queryParams['count'] = ObjectSerializer::toQueryValue($filters['count']);
        }
        // query params
        if ($filters['limit'] !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($filters['limit']);
        }
        // query params
        if ($filters['ids'] !== null) {
            $queryParams['ids'] = ObjectSerializer::toQueryValue($filters['ids']);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNews
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group downloads (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *   "order_by" int  how to order (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getNews(array $filters = [])
    {
        list($response) = $this->getNewsWithHttpInfo($filters);
        return $response;
    }

    /**
     * Operation getNewsWithHttpInfo
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group downloads (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *   "order_by" int  how to order (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNewsWithHttpInfo(array $filters = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getNewsRequest($filters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNewsAsync
     *
     * 
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group downloads (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *   "order_by" int  how to order (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNewsAsync(array $filters = [])
    {
        return $this->getNewsAsyncWithHttpInfo($filters)
            ->then(
                function (array $response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNewsAsyncWithHttpInfo
     *
     * 
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group downloads (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *   "order_by" int  how to order (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNewsAsyncWithHttpInfo(array $filters = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getNewsRequest($filters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function (ResponseInterface $response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (RequestException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNews'
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group downloads (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *   "order_by" int  how to order (optional)
     *
     * @param array $filters API endpoint parameters
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNewsRequest(array $filters = [])
    {
        if (!isset($filters['page'])) {
            $filters['page'] = null;
        }
        if (!isset($filters['count'])) {
            $filters['count'] = null;
        }
        if (!isset($filters['limit'])) {
            $filters['limit'] = null;
        }
        if (!isset($filters['ids'])) {
            $filters['ids'] = null;
        }
        if (!isset($filters['author'])) {
            $filters['author'] = null;
        }
        if (!isset($filters['category'])) {
            $filters['category'] = null;
        }
        if (!isset($filters['group_by'])) {
            $filters['group_by'] = null;
        }
        if (!isset($filters['status'])) {
            $filters['status'] = null;
        }
        if (!isset($filters['hidden_status'])) {
            $filters['hidden_status'] = null;
        }
        if (!isset($filters['period_created'])) {
            $filters['period_created'] = null;
        }
        if (!isset($filters['period_last_comment'])) {
            $filters['period_last_comment'] = null;
        }
        if (!isset($filters['period_published'])) {
            $filters['period_published'] = null;
        }
        if (!isset($filters['period_updated'])) {
            $filters['period_updated'] = null;
        }
        if (!isset($filters['order_by'])) {
            $filters['order_by'] = null;
        }
        

        $resourcePath = '/news';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        
        // query params
        if ($filters['page'] !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($filters['page']);
        }
        // query params
        if ($filters['count'] !== null) {
            $queryParams['count'] = ObjectSerializer::toQueryValue($filters['count']);
        }
        // query params
        if ($filters['limit'] !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($filters['limit']);
        }
        // query params
        if ($filters['ids'] !== null) {
            $queryParams['ids'] = ObjectSerializer::toQueryValue($filters['ids']);
        }
        // query params
        if ($filters['author'] !== null) {
            $queryParams['author'] = ObjectSerializer::toQueryValue($filters['author']);
        }
        // query params
        if ($filters['category'] !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($filters['category']);
        }
        // query params
        if ($filters['group_by'] !== null) {
            $queryParams['group_by'] = ObjectSerializer::toQueryValue($filters['group_by']);
        }
        // query params
        if ($filters['status'] !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($filters['status']);
        }
        // query params
        if ($filters['hidden_status'] !== null) {
            $queryParams['hidden_status'] = ObjectSerializer::toQueryValue($filters['hidden_status']);
        }
        // query params
        if ($filters['period_created'] !== null) {
            $queryParams['period_created'] = ObjectSerializer::toQueryValue($filters['period_created']);
        }
        // query params
        if ($filters['period_last_comment'] !== null) {
            $queryParams['period_last_comment'] = ObjectSerializer::toQueryValue($filters['period_last_comment']);
        }
        // query params
        if ($filters['period_published'] !== null) {
            $queryParams['period_published'] = ObjectSerializer::toQueryValue($filters['period_published']);
        }
        // query params
        if ($filters['period_updated'] !== null) {
            $queryParams['period_updated'] = ObjectSerializer::toQueryValue($filters['period_updated']);
        }
        // query params
        if ($filters['order_by'] !== null) {
            $queryParams['order_by'] = ObjectSerializer::toQueryValue($filters['order_by']);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNewsById
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getNewsById($id)
    {
        list($response) = $this->getNewsByIdWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getNewsByIdWithHttpInfo
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNewsByIdWithHttpInfo($id)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getNewsByIdRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNewsByIdAsync
     *
     * 
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNewsByIdAsync($id)
    {
        return $this->getNewsByIdAsyncWithHttpInfo($id)
            ->then(
                function (array $response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNewsByIdAsyncWithHttpInfo
     *
     * 
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNewsByIdAsyncWithHttpInfo($id)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getNewsByIdRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function (ResponseInterface $response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (RequestException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNewsById'
     *
     *
     * @param int $id The id of the resource
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNewsByIdRequest($id)
    {
        if (empty($id)) {
            throw new \InvalidArgumentException('Missing parameter "$id" in ContentApi::getNewsByIdRequest().');
        }
        

        $resourcePath = '/news/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($id !== null) {
            $id = ObjectSerializer::toQueryValue($id);
        }
        

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNewsCategories
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getNewsCategories(array $filters = [])
    {
        list($response) = $this->getNewsCategoriesWithHttpInfo($filters);
        return $response;
    }

    /**
     * Operation getNewsCategoriesWithHttpInfo
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNewsCategoriesWithHttpInfo(array $filters = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getNewsCategoriesRequest($filters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNewsCategoriesAsync
     *
     * 
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNewsCategoriesAsync(array $filters = [])
    {
        return $this->getNewsCategoriesAsyncWithHttpInfo($filters)
            ->then(
                function (array $response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNewsCategoriesAsyncWithHttpInfo
     *
     * 
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNewsCategoriesAsyncWithHttpInfo(array $filters = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getNewsCategoriesRequest($filters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function (ResponseInterface $response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (RequestException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNewsCategories'
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *
     * @param array $filters API endpoint parameters
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNewsCategoriesRequest(array $filters = [])
    {
        if (!isset($filters['page'])) {
            $filters['page'] = null;
        }
        if (!isset($filters['count'])) {
            $filters['count'] = null;
        }
        if (!isset($filters['limit'])) {
            $filters['limit'] = null;
        }
        if (!isset($filters['ids'])) {
            $filters['ids'] = null;
        }
        

        $resourcePath = '/news_categories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        
        // query params
        if ($filters['page'] !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($filters['page']);
        }
        // query params
        if ($filters['count'] !== null) {
            $queryParams['count'] = ObjectSerializer::toQueryValue($filters['count']);
        }
        // query params
        if ($filters['limit'] !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($filters['limit']);
        }
        // query params
        if ($filters['ids'] !== null) {
            $queryParams['ids'] = ObjectSerializer::toQueryValue($filters['ids']);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNewsCategoryById
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getNewsCategoryById($id)
    {
        list($response) = $this->getNewsCategoryByIdWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getNewsCategoryByIdWithHttpInfo
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNewsCategoryByIdWithHttpInfo($id)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getNewsCategoryByIdRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNewsCategoryByIdAsync
     *
     * 
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNewsCategoryByIdAsync($id)
    {
        return $this->getNewsCategoryByIdAsyncWithHttpInfo($id)
            ->then(
                function (array $response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNewsCategoryByIdAsyncWithHttpInfo
     *
     * 
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNewsCategoryByIdAsyncWithHttpInfo($id)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getNewsCategoryByIdRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function (ResponseInterface $response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (RequestException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNewsCategoryById'
     *
     *
     * @param int $id The id of the resource
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNewsCategoryByIdRequest($id)
    {
        if (empty($id)) {
            throw new \InvalidArgumentException('Missing parameter "$id" in ContentApi::getNewsCategoryByIdRequest().');
        }
        

        $resourcePath = '/news_categories/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($id !== null) {
            $id = ObjectSerializer::toQueryValue($id);
        }
        

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNewsCategoryCount
     *
     *
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getNewsCategoryCount()
    {
        list($response) = $this->getNewsCategoryCountWithHttpInfo();
        return $response;
    }

    /**
     * Operation getNewsCategoryCountWithHttpInfo
     *
     *
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNewsCategoryCountWithHttpInfo()
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getNewsCategoryCountRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNewsCategoryCountAsync
     *
     * 
     *
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNewsCategoryCountAsync()
    {
        return $this->getNewsCategoryCountAsyncWithHttpInfo()
            ->then(
                function (array $response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNewsCategoryCountAsyncWithHttpInfo
     *
     * 
     *
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNewsCategoryCountAsyncWithHttpInfo()
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getNewsCategoryCountRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function (ResponseInterface $response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (RequestException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNewsCategoryCount'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNewsCategoryCountRequest()
    {
        

        $resourcePath = '/news_categories/counts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNewsCommentById
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getNewsCommentById($id)
    {
        list($response) = $this->getNewsCommentByIdWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getNewsCommentByIdWithHttpInfo
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNewsCommentByIdWithHttpInfo($id)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getNewsCommentByIdRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNewsCommentByIdAsync
     *
     * 
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNewsCommentByIdAsync($id)
    {
        return $this->getNewsCommentByIdAsyncWithHttpInfo($id)
            ->then(
                function (array $response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNewsCommentByIdAsyncWithHttpInfo
     *
     * 
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNewsCommentByIdAsyncWithHttpInfo($id)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getNewsCommentByIdRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function (ResponseInterface $response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (RequestException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNewsCommentById'
     *
     *
     * @param int $id The id of the resource
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNewsCommentByIdRequest($id)
    {
        if (empty($id)) {
            throw new \InvalidArgumentException('Missing parameter "$id" in ContentApi::getNewsCommentByIdRequest().');
        }
        

        $resourcePath = '/news_comments/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($id !== null) {
            $id = ObjectSerializer::toQueryValue($id);
        }
        

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNewsCommentCount
     *
     * Filters:
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "group_by" string  how to groups comments (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getNewsCommentCount(array $filters = [])
    {
        list($response) = $this->getNewsCommentCountWithHttpInfo($filters);
        return $response;
    }

    /**
     * Operation getNewsCommentCountWithHttpInfo
     *
     * Filters:
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "group_by" string  how to groups comments (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNewsCommentCountWithHttpInfo(array $filters = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getNewsCommentCountRequest($filters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNewsCommentCountAsync
     *
     * 
     *
     * Filters:
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "group_by" string  how to groups comments (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNewsCommentCountAsync(array $filters = [])
    {
        return $this->getNewsCommentCountAsyncWithHttpInfo($filters)
            ->then(
                function (array $response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNewsCommentCountAsyncWithHttpInfo
     *
     * 
     *
     * Filters:
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "group_by" string  how to groups comments (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNewsCommentCountAsyncWithHttpInfo(array $filters = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getNewsCommentCountRequest($filters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function (ResponseInterface $response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (RequestException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNewsCommentCount'
     *
     * Filters:
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "group_by" string  how to groups comments (optional)
     *
     * @param array $filters API endpoint parameters
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNewsCommentCountRequest(array $filters = [])
    {
        if (!isset($filters['status'])) {
            $filters['status'] = null;
        }
        if (!isset($filters['is_reviewed'])) {
            $filters['is_reviewed'] = null;
        }
        if (!isset($filters['period_created'])) {
            $filters['period_created'] = null;
        }
        if (!isset($filters['article'])) {
            $filters['article'] = null;
        }
        if (!isset($filters['download'])) {
            $filters['download'] = null;
        }
        if (!isset($filters['news'])) {
            $filters['news'] = null;
        }
        if (!isset($filters['group_by'])) {
            $filters['group_by'] = null;
        }
        

        $resourcePath = '/news_comments/counts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        
        // query params
        if ($filters['status'] !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($filters['status']);
        }
        // query params
        if ($filters['is_reviewed'] !== null) {
            $queryParams['is_reviewed'] = ObjectSerializer::toQueryValue($filters['is_reviewed']);
        }
        // query params
        if ($filters['period_created'] !== null) {
            $queryParams['period_created'] = ObjectSerializer::toQueryValue($filters['period_created']);
        }
        // query params
        if ($filters['article'] !== null) {
            $queryParams['article'] = ObjectSerializer::toQueryValue($filters['article']);
        }
        // query params
        if ($filters['download'] !== null) {
            $queryParams['download'] = ObjectSerializer::toQueryValue($filters['download']);
        }
        // query params
        if ($filters['news'] !== null) {
            $queryParams['news'] = ObjectSerializer::toQueryValue($filters['news']);
        }
        // query params
        if ($filters['group_by'] !== null) {
            $queryParams['group_by'] = ObjectSerializer::toQueryValue($filters['group_by']);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNewsComments
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "order_by" string  how to order comments (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getNewsComments(array $filters = [])
    {
        list($response) = $this->getNewsCommentsWithHttpInfo($filters);
        return $response;
    }

    /**
     * Operation getNewsCommentsWithHttpInfo
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "order_by" string  how to order comments (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNewsCommentsWithHttpInfo(array $filters = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getNewsCommentsRequest($filters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNewsCommentsAsync
     *
     * 
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "order_by" string  how to order comments (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNewsCommentsAsync(array $filters = [])
    {
        return $this->getNewsCommentsAsyncWithHttpInfo($filters)
            ->then(
                function (array $response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNewsCommentsAsyncWithHttpInfo
     *
     * 
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "order_by" string  how to order comments (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNewsCommentsAsyncWithHttpInfo(array $filters = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getNewsCommentsRequest($filters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function (ResponseInterface $response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (RequestException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNewsComments'
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "order_by" string  how to order comments (optional)
     *
     * @param array $filters API endpoint parameters
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNewsCommentsRequest(array $filters = [])
    {
        if (!isset($filters['page'])) {
            $filters['page'] = null;
        }
        if (!isset($filters['count'])) {
            $filters['count'] = null;
        }
        if (!isset($filters['limit'])) {
            $filters['limit'] = null;
        }
        if (!isset($filters['ids'])) {
            $filters['ids'] = null;
        }
        if (!isset($filters['status'])) {
            $filters['status'] = null;
        }
        if (!isset($filters['is_reviewed'])) {
            $filters['is_reviewed'] = null;
        }
        if (!isset($filters['period_created'])) {
            $filters['period_created'] = null;
        }
        if (!isset($filters['article'])) {
            $filters['article'] = null;
        }
        if (!isset($filters['download'])) {
            $filters['download'] = null;
        }
        if (!isset($filters['news'])) {
            $filters['news'] = null;
        }
        if (!isset($filters['order_by'])) {
            $filters['order_by'] = null;
        }
        

        $resourcePath = '/news_comments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        
        // query params
        if ($filters['page'] !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($filters['page']);
        }
        // query params
        if ($filters['count'] !== null) {
            $queryParams['count'] = ObjectSerializer::toQueryValue($filters['count']);
        }
        // query params
        if ($filters['limit'] !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($filters['limit']);
        }
        // query params
        if ($filters['ids'] !== null) {
            $queryParams['ids'] = ObjectSerializer::toQueryValue($filters['ids']);
        }
        // query params
        if ($filters['status'] !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($filters['status']);
        }
        // query params
        if ($filters['is_reviewed'] !== null) {
            $queryParams['is_reviewed'] = ObjectSerializer::toQueryValue($filters['is_reviewed']);
        }
        // query params
        if ($filters['period_created'] !== null) {
            $queryParams['period_created'] = ObjectSerializer::toQueryValue($filters['period_created']);
        }
        // query params
        if ($filters['article'] !== null) {
            $queryParams['article'] = ObjectSerializer::toQueryValue($filters['article']);
        }
        // query params
        if ($filters['download'] !== null) {
            $queryParams['download'] = ObjectSerializer::toQueryValue($filters['download']);
        }
        // query params
        if ($filters['news'] !== null) {
            $queryParams['news'] = ObjectSerializer::toQueryValue($filters['news']);
        }
        // query params
        if ($filters['order_by'] !== null) {
            $queryParams['order_by'] = ObjectSerializer::toQueryValue($filters['order_by']);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNewsCount
     *
     * Filters:
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group counters (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getNewsCount(array $filters = [])
    {
        list($response) = $this->getNewsCountWithHttpInfo($filters);
        return $response;
    }

    /**
     * Operation getNewsCountWithHttpInfo
     *
     * Filters:
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group counters (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNewsCountWithHttpInfo(array $filters = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getNewsCountRequest($filters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNewsCountAsync
     *
     * 
     *
     * Filters:
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group counters (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNewsCountAsync(array $filters = [])
    {
        return $this->getNewsCountAsyncWithHttpInfo($filters)
            ->then(
                function (array $response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNewsCountAsyncWithHttpInfo
     *
     * 
     *
     * Filters:
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group counters (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNewsCountAsyncWithHttpInfo(array $filters = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getNewsCountRequest($filters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function (ResponseInterface $response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (RequestException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNewsCount'
     *
     * Filters:
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group counters (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *
     * @param array $filters API endpoint parameters
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNewsCountRequest(array $filters = [])
    {
        if (!isset($filters['author'])) {
            $filters['author'] = null;
        }
        if (!isset($filters['category'])) {
            $filters['category'] = null;
        }
        if (!isset($filters['group_by'])) {
            $filters['group_by'] = null;
        }
        if (!isset($filters['status'])) {
            $filters['status'] = null;
        }
        if (!isset($filters['hidden_status'])) {
            $filters['hidden_status'] = null;
        }
        if (!isset($filters['period_created'])) {
            $filters['period_created'] = null;
        }
        if (!isset($filters['period_last_comment'])) {
            $filters['period_last_comment'] = null;
        }
        if (!isset($filters['period_published'])) {
            $filters['period_published'] = null;
        }
        if (!isset($filters['period_updated'])) {
            $filters['period_updated'] = null;
        }
        

        $resourcePath = '/news/counts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        
        // query params
        if ($filters['author'] !== null) {
            $queryParams['author'] = ObjectSerializer::toQueryValue($filters['author']);
        }
        // query params
        if ($filters['category'] !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($filters['category']);
        }
        // query params
        if ($filters['group_by'] !== null) {
            $queryParams['group_by'] = ObjectSerializer::toQueryValue($filters['group_by']);
        }
        // query params
        if ($filters['status'] !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($filters['status']);
        }
        // query params
        if ($filters['hidden_status'] !== null) {
            $queryParams['hidden_status'] = ObjectSerializer::toQueryValue($filters['hidden_status']);
        }
        // query params
        if ($filters['period_created'] !== null) {
            $queryParams['period_created'] = ObjectSerializer::toQueryValue($filters['period_created']);
        }
        // query params
        if ($filters['period_last_comment'] !== null) {
            $queryParams['period_last_comment'] = ObjectSerializer::toQueryValue($filters['period_last_comment']);
        }
        // query params
        if ($filters['period_published'] !== null) {
            $queryParams['period_published'] = ObjectSerializer::toQueryValue($filters['period_published']);
        }
        // query params
        if ($filters['period_updated'] !== null) {
            $queryParams['period_updated'] = ObjectSerializer::toQueryValue($filters['period_updated']);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTopicById
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getTopicById($id)
    {
        list($response) = $this->getTopicByIdWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getTopicByIdWithHttpInfo
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTopicByIdWithHttpInfo($id)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getTopicByIdRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTopicByIdAsync
     *
     * 
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTopicByIdAsync($id)
    {
        return $this->getTopicByIdAsyncWithHttpInfo($id)
            ->then(
                function (array $response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTopicByIdAsyncWithHttpInfo
     *
     * 
     *
     *
     * @param int $id The id of the resource
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTopicByIdAsyncWithHttpInfo($id)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getTopicByIdRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function (ResponseInterface $response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (RequestException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTopicById'
     *
     *
     * @param int $id The id of the resource
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTopicByIdRequest($id)
    {
        if (empty($id)) {
            throw new \InvalidArgumentException('Missing parameter "$id" in ContentApi::getTopicByIdRequest().');
        }
        

        $resourcePath = '/topics/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($id !== null) {
            $id = ObjectSerializer::toQueryValue($id);
        }
        

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTopicCount
     *
     * Filters:
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "guide" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group counters (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getTopicCount(array $filters = [])
    {
        list($response) = $this->getTopicCountWithHttpInfo($filters);
        return $response;
    }

    /**
     * Operation getTopicCountWithHttpInfo
     *
     * Filters:
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "guide" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group counters (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTopicCountWithHttpInfo(array $filters = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getTopicCountRequest($filters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTopicCountAsync
     *
     * 
     *
     * Filters:
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "guide" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group counters (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTopicCountAsync(array $filters = [])
    {
        return $this->getTopicCountAsyncWithHttpInfo($filters)
            ->then(
                function (array $response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTopicCountAsyncWithHttpInfo
     *
     * 
     *
     * Filters:
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "guide" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group counters (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTopicCountAsyncWithHttpInfo(array $filters = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getTopicCountRequest($filters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function (ResponseInterface $response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (RequestException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTopicCount'
     *
     * Filters:
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "guide" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group counters (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *
     * @param array $filters API endpoint parameters
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTopicCountRequest(array $filters = [])
    {
        if (!isset($filters['author'])) {
            $filters['author'] = null;
        }
        if (!isset($filters['guide'])) {
            $filters['guide'] = null;
        }
        if (!isset($filters['group_by'])) {
            $filters['group_by'] = null;
        }
        if (!isset($filters['status'])) {
            $filters['status'] = null;
        }
        if (!isset($filters['hidden_status'])) {
            $filters['hidden_status'] = null;
        }
        if (!isset($filters['period_created'])) {
            $filters['period_created'] = null;
        }
        if (!isset($filters['period_last_comment'])) {
            $filters['period_last_comment'] = null;
        }
        if (!isset($filters['period_published'])) {
            $filters['period_published'] = null;
        }
        if (!isset($filters['period_updated'])) {
            $filters['period_updated'] = null;
        }
        

        $resourcePath = '/topics/counts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        
        // query params
        if ($filters['author'] !== null) {
            $queryParams['author'] = ObjectSerializer::toQueryValue($filters['author']);
        }
        // query params
        if ($filters['guide'] !== null) {
            $queryParams['guide'] = ObjectSerializer::toQueryValue($filters['guide']);
        }
        // query params
        if ($filters['group_by'] !== null) {
            $queryParams['group_by'] = ObjectSerializer::toQueryValue($filters['group_by']);
        }
        // query params
        if ($filters['status'] !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($filters['status']);
        }
        // query params
        if ($filters['hidden_status'] !== null) {
            $queryParams['hidden_status'] = ObjectSerializer::toQueryValue($filters['hidden_status']);
        }
        // query params
        if ($filters['period_created'] !== null) {
            $queryParams['period_created'] = ObjectSerializer::toQueryValue($filters['period_created']);
        }
        // query params
        if ($filters['period_last_comment'] !== null) {
            $queryParams['period_last_comment'] = ObjectSerializer::toQueryValue($filters['period_last_comment']);
        }
        // query params
        if ($filters['period_published'] !== null) {
            $queryParams['period_published'] = ObjectSerializer::toQueryValue($filters['period_published']);
        }
        // query params
        if ($filters['period_updated'] !== null) {
            $queryParams['period_updated'] = ObjectSerializer::toQueryValue($filters['period_updated']);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTopics
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "guide" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group downloads (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *   "order_by" int  how to order (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getTopics(array $filters = [])
    {
        list($response) = $this->getTopicsWithHttpInfo($filters);
        return $response;
    }

    /**
     * Operation getTopicsWithHttpInfo
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "guide" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group downloads (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *   "order_by" int  how to order (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTopicsWithHttpInfo(array $filters = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getTopicsRequest($filters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTopicsAsync
     *
     * 
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "guide" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group downloads (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *   "order_by" int  how to order (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTopicsAsync(array $filters = [])
    {
        return $this->getTopicsAsyncWithHttpInfo($filters)
            ->then(
                function (array $response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTopicsAsyncWithHttpInfo
     *
     * 
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "guide" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group downloads (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *   "order_by" int  how to order (optional)
     *
     * @param array $filters API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTopicsAsyncWithHttpInfo(array $filters = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getTopicsRequest($filters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function (ResponseInterface $response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (RequestException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTopics'
     *
     * Filters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "guide" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group downloads (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *   "order_by" int  how to order (optional)
     *
     * @param array $filters API endpoint parameters
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTopicsRequest(array $filters = [])
    {
        if (!isset($filters['page'])) {
            $filters['page'] = null;
        }
        if (!isset($filters['count'])) {
            $filters['count'] = null;
        }
        if (!isset($filters['limit'])) {
            $filters['limit'] = null;
        }
        if (!isset($filters['ids'])) {
            $filters['ids'] = null;
        }
        if (!isset($filters['author'])) {
            $filters['author'] = null;
        }
        if (!isset($filters['guide'])) {
            $filters['guide'] = null;
        }
        if (!isset($filters['group_by'])) {
            $filters['group_by'] = null;
        }
        if (!isset($filters['status'])) {
            $filters['status'] = null;
        }
        if (!isset($filters['hidden_status'])) {
            $filters['hidden_status'] = null;
        }
        if (!isset($filters['period_created'])) {
            $filters['period_created'] = null;
        }
        if (!isset($filters['period_last_comment'])) {
            $filters['period_last_comment'] = null;
        }
        if (!isset($filters['period_published'])) {
            $filters['period_published'] = null;
        }
        if (!isset($filters['period_updated'])) {
            $filters['period_updated'] = null;
        }
        if (!isset($filters['order_by'])) {
            $filters['order_by'] = null;
        }
        

        $resourcePath = '/topics';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        
        // query params
        if ($filters['page'] !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($filters['page']);
        }
        // query params
        if ($filters['count'] !== null) {
            $queryParams['count'] = ObjectSerializer::toQueryValue($filters['count']);
        }
        // query params
        if ($filters['limit'] !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($filters['limit']);
        }
        // query params
        if ($filters['ids'] !== null) {
            $queryParams['ids'] = ObjectSerializer::toQueryValue($filters['ids']);
        }
        // query params
        if ($filters['author'] !== null) {
            $queryParams['author'] = ObjectSerializer::toQueryValue($filters['author']);
        }
        // query params
        if ($filters['guide'] !== null) {
            $queryParams['guide'] = ObjectSerializer::toQueryValue($filters['guide']);
        }
        // query params
        if ($filters['group_by'] !== null) {
            $queryParams['group_by'] = ObjectSerializer::toQueryValue($filters['group_by']);
        }
        // query params
        if ($filters['status'] !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($filters['status']);
        }
        // query params
        if ($filters['hidden_status'] !== null) {
            $queryParams['hidden_status'] = ObjectSerializer::toQueryValue($filters['hidden_status']);
        }
        // query params
        if ($filters['period_created'] !== null) {
            $queryParams['period_created'] = ObjectSerializer::toQueryValue($filters['period_created']);
        }
        // query params
        if ($filters['period_last_comment'] !== null) {
            $queryParams['period_last_comment'] = ObjectSerializer::toQueryValue($filters['period_last_comment']);
        }
        // query params
        if ($filters['period_published'] !== null) {
            $queryParams['period_published'] = ObjectSerializer::toQueryValue($filters['period_published']);
        }
        // query params
        if ($filters['period_updated'] !== null) {
            $queryParams['period_updated'] = ObjectSerializer::toQueryValue($filters['period_updated']);
        }
        // query params
        if ($filters['order_by'] !== null) {
            $queryParams['order_by'] = ObjectSerializer::toQueryValue($filters['order_by']);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateGuideByGuideIdTree
     *
     *
     * @param string $guide_id 
     * @param string[] $tree 
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function updateGuideByGuideIdTree($guide_id, $tree)
    {
        list($response) = $this->updateGuideByGuideIdTreeWithHttpInfo($guide_id, $tree);
        return $response;
    }

    /**
     * Operation updateGuideByGuideIdTreeWithHttpInfo
     *
     *
     * @param string $guide_id 
     * @param string[] $tree 
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateGuideByGuideIdTreeWithHttpInfo($guide_id, $tree)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->updateGuideByGuideIdTreeRequest($guide_id, $tree);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateGuideByGuideIdTreeAsync
     *
     * 
     *
     *
     * @param string $guide_id 
     * @param string[] $tree 
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateGuideByGuideIdTreeAsync($guide_id, $tree)
    {
        return $this->updateGuideByGuideIdTreeAsyncWithHttpInfo($guide_id, $tree)
            ->then(
                function (array $response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateGuideByGuideIdTreeAsyncWithHttpInfo
     *
     * 
     *
     *
     * @param string $guide_id 
     * @param string[] $tree 
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateGuideByGuideIdTreeAsyncWithHttpInfo($guide_id, $tree)
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->updateGuideByGuideIdTreeRequest($guide_id, $tree);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function (ResponseInterface $response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (RequestException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateGuideByGuideIdTree'
     *
     *
     * @param string $guide_id 
     * @param string[] $tree 
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateGuideByGuideIdTreeRequest($guide_id, $tree)
    {
        if (empty($guide_id)) {
            throw new \InvalidArgumentException('Missing parameter "$guide_id" in ContentApi::updateGuideByGuideIdTreeRequest().');
        }
        if (empty($tree)) {
            throw new \InvalidArgumentException('Missing parameter "$tree" in ContentApi::updateGuideByGuideIdTreeRequest().');
        }
        

        $resourcePath = '/guides/{guideId}/tree';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        if ($guide_id !== null) {
            $guide_id = ObjectSerializer::toQueryValue($guide_id);
        }
        if (is_array($tree)) {
            $tree = ObjectSerializer::serializeCollection($tree, 'csv', true);
        }
        if ($tree !== null) {
            $tree = ObjectSerializer::toQueryValue($tree);
        }
        
        // query params
        if (is_array($filters['tree'])) {
            $filters['tree'] = ObjectSerializer::serializeCollection($filters['tree'], 'csv', true);
        }
        if ($filters['tree'] !== null) {
            $queryParams['tree'] = ObjectSerializer::toQueryValue($filters['tree']);
        }

        // path params
        if ($guide_id !== null) {
            $resourcePath = str_replace(
                '{' . 'guideId' . '}',
                ObjectSerializer::toPathValue($guide_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
