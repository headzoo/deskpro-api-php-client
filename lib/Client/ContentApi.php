<?php
/*
 * DeskPRO (r) has been developed by DeskPRO Ltd. https://www.deskpro.com/
 * a British company located in London, England.
 *
 * All source code and content Copyright (c) 2017, DeskPRO Ltd.
 *
 * The license agreement under which this software is released
 * can be found at https://www.deskpro.com/eula/
 *
 * By using this software, you acknowledge having read the license
 * and agree to be bound thereby.
 *
 * Please note that DeskPRO is not free software. We release the full
 * source code for our software because we trust our users to pay us for
 * the huge investment in time and energy that has gone into both creating
 * this software and supporting our customers. By providing the source code
 * we preserve our customers' ability to modify, audit and learn from our
 * work. We have been developing DeskPRO since 2001, please help us make it
 * another decade.
 *
 * Like the work you see? Think you could make it better? We are always
 * looking for great developers to join us: http://www.deskpro.com/jobs/
 *
 * ~ Thanks, Everyone at Team DeskPRO
 */

/**
 * ContentApi
 * PHP version 5
 *
 * @category Class
 * @package  DeskPRO\API
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * DeskPRO API
 *
 * DeskPRO API
 *
 * OpenAPI spec version: 2.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace DeskPRO\API\Client;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use DeskPRO\API\ApiException;
use DeskPRO\API\Configuration;
use DeskPRO\API\HeaderSelector;
use DeskPRO\API\ObjectSerializer;

/**
 * ContentApi Class Doc Comment
 *
 * @category Class
 * @package  DeskPRO\API
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ContentApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;
    
    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        Configuration $config = null,
        ClientInterface $client = null,
        HeaderSelector $selector = null
    ) {
        $this->config = $config ?: new Configuration();
        $this->client = $client ?: new Client();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation deleteArticleById
     *
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function deleteArticleById(array $params = [])
    {
        list($response) = $this->deleteArticleByIdWithHttpInfo($params);
        return $response;
    }

    /**
     * Operation deleteArticleByIdWithHttpInfo
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteArticleByIdWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->deleteArticleByIdRequest($params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteArticleByIdAsync
     *
     * 
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteArticleByIdAsync(array $params = [])
    {
        return $this->deleteArticleByIdAsyncWithHttpInfo($params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteArticleByIdAsyncWithHttpInfo
     *
     * 
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteArticleByIdAsyncWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->deleteArticleByIdRequest($params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteArticleById'
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteArticleByIdRequest(array $params = [])
    {
        if (empty($params['id'])) {
            throw new \InvalidArgumentException('Missing parameter "id" in ContentApi::deleteArticleByIdRequest().');
        }
        

        $resourcePath = '/articles/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($params['id'] !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($params['id']),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteArticleCategoryById
     *
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function deleteArticleCategoryById(array $params = [])
    {
        list($response) = $this->deleteArticleCategoryByIdWithHttpInfo($params);
        return $response;
    }

    /**
     * Operation deleteArticleCategoryByIdWithHttpInfo
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteArticleCategoryByIdWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->deleteArticleCategoryByIdRequest($params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteArticleCategoryByIdAsync
     *
     * 
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteArticleCategoryByIdAsync(array $params = [])
    {
        return $this->deleteArticleCategoryByIdAsyncWithHttpInfo($params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteArticleCategoryByIdAsyncWithHttpInfo
     *
     * 
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteArticleCategoryByIdAsyncWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->deleteArticleCategoryByIdRequest($params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteArticleCategoryById'
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteArticleCategoryByIdRequest(array $params = [])
    {
        if (empty($params['id'])) {
            throw new \InvalidArgumentException('Missing parameter "id" in ContentApi::deleteArticleCategoryByIdRequest().');
        }
        

        $resourcePath = '/article_categories/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($params['id'] !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($params['id']),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteArticleCommentById
     *
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function deleteArticleCommentById(array $params = [])
    {
        list($response) = $this->deleteArticleCommentByIdWithHttpInfo($params);
        return $response;
    }

    /**
     * Operation deleteArticleCommentByIdWithHttpInfo
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteArticleCommentByIdWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->deleteArticleCommentByIdRequest($params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteArticleCommentByIdAsync
     *
     * 
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteArticleCommentByIdAsync(array $params = [])
    {
        return $this->deleteArticleCommentByIdAsyncWithHttpInfo($params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteArticleCommentByIdAsyncWithHttpInfo
     *
     * 
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteArticleCommentByIdAsyncWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->deleteArticleCommentByIdRequest($params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteArticleCommentById'
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteArticleCommentByIdRequest(array $params = [])
    {
        if (empty($params['id'])) {
            throw new \InvalidArgumentException('Missing parameter "id" in ContentApi::deleteArticleCommentByIdRequest().');
        }
        

        $resourcePath = '/article_comments/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($params['id'] !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($params['id']),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteArticlePendingCreateById
     *
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function deleteArticlePendingCreateById(array $params = [])
    {
        list($response) = $this->deleteArticlePendingCreateByIdWithHttpInfo($params);
        return $response;
    }

    /**
     * Operation deleteArticlePendingCreateByIdWithHttpInfo
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteArticlePendingCreateByIdWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->deleteArticlePendingCreateByIdRequest($params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteArticlePendingCreateByIdAsync
     *
     * 
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteArticlePendingCreateByIdAsync(array $params = [])
    {
        return $this->deleteArticlePendingCreateByIdAsyncWithHttpInfo($params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteArticlePendingCreateByIdAsyncWithHttpInfo
     *
     * 
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteArticlePendingCreateByIdAsyncWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->deleteArticlePendingCreateByIdRequest($params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteArticlePendingCreateById'
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteArticlePendingCreateByIdRequest(array $params = [])
    {
        if (empty($params['id'])) {
            throw new \InvalidArgumentException('Missing parameter "id" in ContentApi::deleteArticlePendingCreateByIdRequest().');
        }
        

        $resourcePath = '/article_pending_creates/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($params['id'] !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($params['id']),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteDownloadById
     *
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function deleteDownloadById(array $params = [])
    {
        list($response) = $this->deleteDownloadByIdWithHttpInfo($params);
        return $response;
    }

    /**
     * Operation deleteDownloadByIdWithHttpInfo
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteDownloadByIdWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->deleteDownloadByIdRequest($params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteDownloadByIdAsync
     *
     * 
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDownloadByIdAsync(array $params = [])
    {
        return $this->deleteDownloadByIdAsyncWithHttpInfo($params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteDownloadByIdAsyncWithHttpInfo
     *
     * 
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDownloadByIdAsyncWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->deleteDownloadByIdRequest($params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteDownloadById'
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteDownloadByIdRequest(array $params = [])
    {
        if (empty($params['id'])) {
            throw new \InvalidArgumentException('Missing parameter "id" in ContentApi::deleteDownloadByIdRequest().');
        }
        

        $resourcePath = '/downloads/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($params['id'] !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($params['id']),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteDownloadCategoryById
     *
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function deleteDownloadCategoryById(array $params = [])
    {
        list($response) = $this->deleteDownloadCategoryByIdWithHttpInfo($params);
        return $response;
    }

    /**
     * Operation deleteDownloadCategoryByIdWithHttpInfo
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteDownloadCategoryByIdWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->deleteDownloadCategoryByIdRequest($params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteDownloadCategoryByIdAsync
     *
     * 
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDownloadCategoryByIdAsync(array $params = [])
    {
        return $this->deleteDownloadCategoryByIdAsyncWithHttpInfo($params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteDownloadCategoryByIdAsyncWithHttpInfo
     *
     * 
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDownloadCategoryByIdAsyncWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->deleteDownloadCategoryByIdRequest($params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteDownloadCategoryById'
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteDownloadCategoryByIdRequest(array $params = [])
    {
        if (empty($params['id'])) {
            throw new \InvalidArgumentException('Missing parameter "id" in ContentApi::deleteDownloadCategoryByIdRequest().');
        }
        

        $resourcePath = '/download_categories/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($params['id'] !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($params['id']),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteDownloadCommentById
     *
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function deleteDownloadCommentById(array $params = [])
    {
        list($response) = $this->deleteDownloadCommentByIdWithHttpInfo($params);
        return $response;
    }

    /**
     * Operation deleteDownloadCommentByIdWithHttpInfo
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteDownloadCommentByIdWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->deleteDownloadCommentByIdRequest($params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteDownloadCommentByIdAsync
     *
     * 
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDownloadCommentByIdAsync(array $params = [])
    {
        return $this->deleteDownloadCommentByIdAsyncWithHttpInfo($params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteDownloadCommentByIdAsyncWithHttpInfo
     *
     * 
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDownloadCommentByIdAsyncWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->deleteDownloadCommentByIdRequest($params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteDownloadCommentById'
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteDownloadCommentByIdRequest(array $params = [])
    {
        if (empty($params['id'])) {
            throw new \InvalidArgumentException('Missing parameter "id" in ContentApi::deleteDownloadCommentByIdRequest().');
        }
        

        $resourcePath = '/download_comments/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($params['id'] !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($params['id']),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteGuideById
     *
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function deleteGuideById(array $params = [])
    {
        list($response) = $this->deleteGuideByIdWithHttpInfo($params);
        return $response;
    }

    /**
     * Operation deleteGuideByIdWithHttpInfo
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteGuideByIdWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->deleteGuideByIdRequest($params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteGuideByIdAsync
     *
     * 
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteGuideByIdAsync(array $params = [])
    {
        return $this->deleteGuideByIdAsyncWithHttpInfo($params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteGuideByIdAsyncWithHttpInfo
     *
     * 
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteGuideByIdAsyncWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->deleteGuideByIdRequest($params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteGuideById'
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteGuideByIdRequest(array $params = [])
    {
        if (empty($params['id'])) {
            throw new \InvalidArgumentException('Missing parameter "id" in ContentApi::deleteGuideByIdRequest().');
        }
        

        $resourcePath = '/guides/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($params['id'] !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($params['id']),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteNewsById
     *
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function deleteNewsById(array $params = [])
    {
        list($response) = $this->deleteNewsByIdWithHttpInfo($params);
        return $response;
    }

    /**
     * Operation deleteNewsByIdWithHttpInfo
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteNewsByIdWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->deleteNewsByIdRequest($params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteNewsByIdAsync
     *
     * 
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNewsByIdAsync(array $params = [])
    {
        return $this->deleteNewsByIdAsyncWithHttpInfo($params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteNewsByIdAsyncWithHttpInfo
     *
     * 
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNewsByIdAsyncWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->deleteNewsByIdRequest($params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteNewsById'
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteNewsByIdRequest(array $params = [])
    {
        if (empty($params['id'])) {
            throw new \InvalidArgumentException('Missing parameter "id" in ContentApi::deleteNewsByIdRequest().');
        }
        

        $resourcePath = '/news/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($params['id'] !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($params['id']),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteNewsCategoryById
     *
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function deleteNewsCategoryById(array $params = [])
    {
        list($response) = $this->deleteNewsCategoryByIdWithHttpInfo($params);
        return $response;
    }

    /**
     * Operation deleteNewsCategoryByIdWithHttpInfo
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteNewsCategoryByIdWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->deleteNewsCategoryByIdRequest($params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteNewsCategoryByIdAsync
     *
     * 
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNewsCategoryByIdAsync(array $params = [])
    {
        return $this->deleteNewsCategoryByIdAsyncWithHttpInfo($params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteNewsCategoryByIdAsyncWithHttpInfo
     *
     * 
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNewsCategoryByIdAsyncWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->deleteNewsCategoryByIdRequest($params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteNewsCategoryById'
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteNewsCategoryByIdRequest(array $params = [])
    {
        if (empty($params['id'])) {
            throw new \InvalidArgumentException('Missing parameter "id" in ContentApi::deleteNewsCategoryByIdRequest().');
        }
        

        $resourcePath = '/news_categories/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($params['id'] !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($params['id']),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteNewsCommentById
     *
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function deleteNewsCommentById(array $params = [])
    {
        list($response) = $this->deleteNewsCommentByIdWithHttpInfo($params);
        return $response;
    }

    /**
     * Operation deleteNewsCommentByIdWithHttpInfo
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteNewsCommentByIdWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->deleteNewsCommentByIdRequest($params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteNewsCommentByIdAsync
     *
     * 
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNewsCommentByIdAsync(array $params = [])
    {
        return $this->deleteNewsCommentByIdAsyncWithHttpInfo($params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteNewsCommentByIdAsyncWithHttpInfo
     *
     * 
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNewsCommentByIdAsyncWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->deleteNewsCommentByIdRequest($params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteNewsCommentById'
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteNewsCommentByIdRequest(array $params = [])
    {
        if (empty($params['id'])) {
            throw new \InvalidArgumentException('Missing parameter "id" in ContentApi::deleteNewsCommentByIdRequest().');
        }
        

        $resourcePath = '/news_comments/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($params['id'] !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($params['id']),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteTopicById
     *
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function deleteTopicById(array $params = [])
    {
        list($response) = $this->deleteTopicByIdWithHttpInfo($params);
        return $response;
    }

    /**
     * Operation deleteTopicByIdWithHttpInfo
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteTopicByIdWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->deleteTopicByIdRequest($params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteTopicByIdAsync
     *
     * 
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTopicByIdAsync(array $params = [])
    {
        return $this->deleteTopicByIdAsyncWithHttpInfo($params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteTopicByIdAsyncWithHttpInfo
     *
     * 
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTopicByIdAsyncWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->deleteTopicByIdRequest($params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteTopicById'
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteTopicByIdRequest(array $params = [])
    {
        if (empty($params['id'])) {
            throw new \InvalidArgumentException('Missing parameter "id" in ContentApi::deleteTopicByIdRequest().');
        }
        

        $resourcePath = '/topics/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($params['id'] !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($params['id']),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getArticleById
     *
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getArticleById(array $params = [])
    {
        list($response) = $this->getArticleByIdWithHttpInfo($params);
        return $response;
    }

    /**
     * Operation getArticleByIdWithHttpInfo
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getArticleByIdWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getArticleByIdRequest($params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getArticleByIdAsync
     *
     * 
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArticleByIdAsync(array $params = [])
    {
        return $this->getArticleByIdAsyncWithHttpInfo($params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getArticleByIdAsyncWithHttpInfo
     *
     * 
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArticleByIdAsyncWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getArticleByIdRequest($params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getArticleById'
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getArticleByIdRequest(array $params = [])
    {
        if (empty($params['id'])) {
            throw new \InvalidArgumentException('Missing parameter "id" in ContentApi::getArticleByIdRequest().');
        }
        

        $resourcePath = '/articles/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($params['id'] !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($params['id']),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getArticleCategories
     *
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getArticleCategories(array $params = [])
    {
        list($response) = $this->getArticleCategoriesWithHttpInfo($params);
        return $response;
    }

    /**
     * Operation getArticleCategoriesWithHttpInfo
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getArticleCategoriesWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getArticleCategoriesRequest($params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getArticleCategoriesAsync
     *
     * 
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArticleCategoriesAsync(array $params = [])
    {
        return $this->getArticleCategoriesAsyncWithHttpInfo($params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getArticleCategoriesAsyncWithHttpInfo
     *
     * 
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArticleCategoriesAsyncWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getArticleCategoriesRequest($params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getArticleCategories'
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getArticleCategoriesRequest(array $params = [])
    {
        if (!isset($params['page'])) {
            $params['page'] = null;
        }
        if (!isset($params['count'])) {
            $params['count'] = null;
        }
        if (!isset($params['limit'])) {
            $params['limit'] = null;
        }
        if (!isset($params['ids'])) {
            $params['ids'] = null;
        }
        

        $resourcePath = '/article_categories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($params['page'] !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($params['page']);
        }
        // query params
        if ($params['count'] !== null) {
            $queryParams['count'] = ObjectSerializer::toQueryValue($params['count']);
        }
        // query params
        if ($params['limit'] !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($params['limit']);
        }
        // query params
        if ($params['ids'] !== null) {
            $queryParams['ids'] = ObjectSerializer::toQueryValue($params['ids']);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getArticleCategoryById
     *
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getArticleCategoryById(array $params = [])
    {
        list($response) = $this->getArticleCategoryByIdWithHttpInfo($params);
        return $response;
    }

    /**
     * Operation getArticleCategoryByIdWithHttpInfo
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getArticleCategoryByIdWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getArticleCategoryByIdRequest($params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getArticleCategoryByIdAsync
     *
     * 
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArticleCategoryByIdAsync(array $params = [])
    {
        return $this->getArticleCategoryByIdAsyncWithHttpInfo($params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getArticleCategoryByIdAsyncWithHttpInfo
     *
     * 
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArticleCategoryByIdAsyncWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getArticleCategoryByIdRequest($params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getArticleCategoryById'
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getArticleCategoryByIdRequest(array $params = [])
    {
        if (empty($params['id'])) {
            throw new \InvalidArgumentException('Missing parameter "id" in ContentApi::getArticleCategoryByIdRequest().');
        }
        

        $resourcePath = '/article_categories/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($params['id'] !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($params['id']),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getArticleCategoryCount
     *
     *
     * Parameters:
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getArticleCategoryCount(array $params = [])
    {
        list($response) = $this->getArticleCategoryCountWithHttpInfo($params);
        return $response;
    }

    /**
     * Operation getArticleCategoryCountWithHttpInfo
     *
     * Parameters:
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getArticleCategoryCountWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getArticleCategoryCountRequest($params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getArticleCategoryCountAsync
     *
     * 
     *
     * Parameters:
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArticleCategoryCountAsync(array $params = [])
    {
        return $this->getArticleCategoryCountAsyncWithHttpInfo($params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getArticleCategoryCountAsyncWithHttpInfo
     *
     * 
     *
     * Parameters:
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArticleCategoryCountAsyncWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getArticleCategoryCountRequest($params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getArticleCategoryCount'
     *
     * Parameters:
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getArticleCategoryCountRequest(array $params = [])
    {
        

        $resourcePath = '/article_categories/counts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getArticleCommentById
     *
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getArticleCommentById(array $params = [])
    {
        list($response) = $this->getArticleCommentByIdWithHttpInfo($params);
        return $response;
    }

    /**
     * Operation getArticleCommentByIdWithHttpInfo
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getArticleCommentByIdWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getArticleCommentByIdRequest($params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getArticleCommentByIdAsync
     *
     * 
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArticleCommentByIdAsync(array $params = [])
    {
        return $this->getArticleCommentByIdAsyncWithHttpInfo($params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getArticleCommentByIdAsyncWithHttpInfo
     *
     * 
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArticleCommentByIdAsyncWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getArticleCommentByIdRequest($params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getArticleCommentById'
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getArticleCommentByIdRequest(array $params = [])
    {
        if (empty($params['id'])) {
            throw new \InvalidArgumentException('Missing parameter "id" in ContentApi::getArticleCommentByIdRequest().');
        }
        

        $resourcePath = '/article_comments/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($params['id'] !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($params['id']),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getArticleCommentCount
     *
     *
     * Parameters:
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "group_by" string  how to groups comments (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getArticleCommentCount(array $params = [])
    {
        list($response) = $this->getArticleCommentCountWithHttpInfo($params);
        return $response;
    }

    /**
     * Operation getArticleCommentCountWithHttpInfo
     *
     * Parameters:
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "group_by" string  how to groups comments (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getArticleCommentCountWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getArticleCommentCountRequest($params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getArticleCommentCountAsync
     *
     * 
     *
     * Parameters:
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "group_by" string  how to groups comments (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArticleCommentCountAsync(array $params = [])
    {
        return $this->getArticleCommentCountAsyncWithHttpInfo($params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getArticleCommentCountAsyncWithHttpInfo
     *
     * 
     *
     * Parameters:
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "group_by" string  how to groups comments (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArticleCommentCountAsyncWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getArticleCommentCountRequest($params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getArticleCommentCount'
     *
     * Parameters:
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "group_by" string  how to groups comments (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getArticleCommentCountRequest(array $params = [])
    {
        if (!isset($params['status'])) {
            $params['status'] = null;
        }
        if (!isset($params['is_reviewed'])) {
            $params['is_reviewed'] = null;
        }
        if (!isset($params['period_created'])) {
            $params['period_created'] = null;
        }
        if (!isset($params['article'])) {
            $params['article'] = null;
        }
        if (!isset($params['download'])) {
            $params['download'] = null;
        }
        if (!isset($params['news'])) {
            $params['news'] = null;
        }
        if (!isset($params['group_by'])) {
            $params['group_by'] = null;
        }
        

        $resourcePath = '/article_comments/counts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($params['status'] !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($params['status']);
        }
        // query params
        if ($params['is_reviewed'] !== null) {
            $queryParams['is_reviewed'] = ObjectSerializer::toQueryValue($params['is_reviewed']);
        }
        // query params
        if ($params['period_created'] !== null) {
            $queryParams['period_created'] = ObjectSerializer::toQueryValue($params['period_created']);
        }
        // query params
        if ($params['article'] !== null) {
            $queryParams['article'] = ObjectSerializer::toQueryValue($params['article']);
        }
        // query params
        if ($params['download'] !== null) {
            $queryParams['download'] = ObjectSerializer::toQueryValue($params['download']);
        }
        // query params
        if ($params['news'] !== null) {
            $queryParams['news'] = ObjectSerializer::toQueryValue($params['news']);
        }
        // query params
        if ($params['group_by'] !== null) {
            $queryParams['group_by'] = ObjectSerializer::toQueryValue($params['group_by']);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getArticleComments
     *
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "order_by" string  how to order comments (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getArticleComments(array $params = [])
    {
        list($response) = $this->getArticleCommentsWithHttpInfo($params);
        return $response;
    }

    /**
     * Operation getArticleCommentsWithHttpInfo
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "order_by" string  how to order comments (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getArticleCommentsWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getArticleCommentsRequest($params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getArticleCommentsAsync
     *
     * 
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "order_by" string  how to order comments (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArticleCommentsAsync(array $params = [])
    {
        return $this->getArticleCommentsAsyncWithHttpInfo($params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getArticleCommentsAsyncWithHttpInfo
     *
     * 
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "order_by" string  how to order comments (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArticleCommentsAsyncWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getArticleCommentsRequest($params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getArticleComments'
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "order_by" string  how to order comments (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getArticleCommentsRequest(array $params = [])
    {
        if (!isset($params['page'])) {
            $params['page'] = null;
        }
        if (!isset($params['count'])) {
            $params['count'] = null;
        }
        if (!isset($params['limit'])) {
            $params['limit'] = null;
        }
        if (!isset($params['ids'])) {
            $params['ids'] = null;
        }
        if (!isset($params['status'])) {
            $params['status'] = null;
        }
        if (!isset($params['is_reviewed'])) {
            $params['is_reviewed'] = null;
        }
        if (!isset($params['period_created'])) {
            $params['period_created'] = null;
        }
        if (!isset($params['article'])) {
            $params['article'] = null;
        }
        if (!isset($params['download'])) {
            $params['download'] = null;
        }
        if (!isset($params['news'])) {
            $params['news'] = null;
        }
        if (!isset($params['order_by'])) {
            $params['order_by'] = null;
        }
        

        $resourcePath = '/article_comments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($params['page'] !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($params['page']);
        }
        // query params
        if ($params['count'] !== null) {
            $queryParams['count'] = ObjectSerializer::toQueryValue($params['count']);
        }
        // query params
        if ($params['limit'] !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($params['limit']);
        }
        // query params
        if ($params['ids'] !== null) {
            $queryParams['ids'] = ObjectSerializer::toQueryValue($params['ids']);
        }
        // query params
        if ($params['status'] !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($params['status']);
        }
        // query params
        if ($params['is_reviewed'] !== null) {
            $queryParams['is_reviewed'] = ObjectSerializer::toQueryValue($params['is_reviewed']);
        }
        // query params
        if ($params['period_created'] !== null) {
            $queryParams['period_created'] = ObjectSerializer::toQueryValue($params['period_created']);
        }
        // query params
        if ($params['article'] !== null) {
            $queryParams['article'] = ObjectSerializer::toQueryValue($params['article']);
        }
        // query params
        if ($params['download'] !== null) {
            $queryParams['download'] = ObjectSerializer::toQueryValue($params['download']);
        }
        // query params
        if ($params['news'] !== null) {
            $queryParams['news'] = ObjectSerializer::toQueryValue($params['news']);
        }
        // query params
        if ($params['order_by'] !== null) {
            $queryParams['order_by'] = ObjectSerializer::toQueryValue($params['order_by']);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getArticleCount
     *
     *
     * Parameters:
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group counters (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getArticleCount(array $params = [])
    {
        list($response) = $this->getArticleCountWithHttpInfo($params);
        return $response;
    }

    /**
     * Operation getArticleCountWithHttpInfo
     *
     * Parameters:
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group counters (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getArticleCountWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getArticleCountRequest($params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getArticleCountAsync
     *
     * 
     *
     * Parameters:
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group counters (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArticleCountAsync(array $params = [])
    {
        return $this->getArticleCountAsyncWithHttpInfo($params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getArticleCountAsyncWithHttpInfo
     *
     * 
     *
     * Parameters:
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group counters (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArticleCountAsyncWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getArticleCountRequest($params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getArticleCount'
     *
     * Parameters:
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group counters (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getArticleCountRequest(array $params = [])
    {
        if (!isset($params['author'])) {
            $params['author'] = null;
        }
        if (!isset($params['category'])) {
            $params['category'] = null;
        }
        if (!isset($params['group_by'])) {
            $params['group_by'] = null;
        }
        if (!isset($params['status'])) {
            $params['status'] = null;
        }
        if (!isset($params['hidden_status'])) {
            $params['hidden_status'] = null;
        }
        if (!isset($params['period_created'])) {
            $params['period_created'] = null;
        }
        if (!isset($params['period_last_comment'])) {
            $params['period_last_comment'] = null;
        }
        if (!isset($params['period_published'])) {
            $params['period_published'] = null;
        }
        if (!isset($params['period_updated'])) {
            $params['period_updated'] = null;
        }
        

        $resourcePath = '/articles/counts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($params['author'] !== null) {
            $queryParams['author'] = ObjectSerializer::toQueryValue($params['author']);
        }
        // query params
        if ($params['category'] !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($params['category']);
        }
        // query params
        if ($params['group_by'] !== null) {
            $queryParams['group_by'] = ObjectSerializer::toQueryValue($params['group_by']);
        }
        // query params
        if ($params['status'] !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($params['status']);
        }
        // query params
        if ($params['hidden_status'] !== null) {
            $queryParams['hidden_status'] = ObjectSerializer::toQueryValue($params['hidden_status']);
        }
        // query params
        if ($params['period_created'] !== null) {
            $queryParams['period_created'] = ObjectSerializer::toQueryValue($params['period_created']);
        }
        // query params
        if ($params['period_last_comment'] !== null) {
            $queryParams['period_last_comment'] = ObjectSerializer::toQueryValue($params['period_last_comment']);
        }
        // query params
        if ($params['period_published'] !== null) {
            $queryParams['period_published'] = ObjectSerializer::toQueryValue($params['period_published']);
        }
        // query params
        if ($params['period_updated'] !== null) {
            $queryParams['period_updated'] = ObjectSerializer::toQueryValue($params['period_updated']);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getArticlePendingCreateById
     *
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getArticlePendingCreateById(array $params = [])
    {
        list($response) = $this->getArticlePendingCreateByIdWithHttpInfo($params);
        return $response;
    }

    /**
     * Operation getArticlePendingCreateByIdWithHttpInfo
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getArticlePendingCreateByIdWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getArticlePendingCreateByIdRequest($params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getArticlePendingCreateByIdAsync
     *
     * 
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArticlePendingCreateByIdAsync(array $params = [])
    {
        return $this->getArticlePendingCreateByIdAsyncWithHttpInfo($params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getArticlePendingCreateByIdAsyncWithHttpInfo
     *
     * 
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArticlePendingCreateByIdAsyncWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getArticlePendingCreateByIdRequest($params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getArticlePendingCreateById'
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getArticlePendingCreateByIdRequest(array $params = [])
    {
        if (empty($params['id'])) {
            throw new \InvalidArgumentException('Missing parameter "id" in ContentApi::getArticlePendingCreateByIdRequest().');
        }
        

        $resourcePath = '/article_pending_creates/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($params['id'] !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($params['id']),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getArticlePendingCreateCount
     *
     *
     * Parameters:
     *   "assigned_person" string   (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getArticlePendingCreateCount(array $params = [])
    {
        list($response) = $this->getArticlePendingCreateCountWithHttpInfo($params);
        return $response;
    }

    /**
     * Operation getArticlePendingCreateCountWithHttpInfo
     *
     * Parameters:
     *   "assigned_person" string   (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getArticlePendingCreateCountWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getArticlePendingCreateCountRequest($params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getArticlePendingCreateCountAsync
     *
     * 
     *
     * Parameters:
     *   "assigned_person" string   (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArticlePendingCreateCountAsync(array $params = [])
    {
        return $this->getArticlePendingCreateCountAsyncWithHttpInfo($params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getArticlePendingCreateCountAsyncWithHttpInfo
     *
     * 
     *
     * Parameters:
     *   "assigned_person" string   (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArticlePendingCreateCountAsyncWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getArticlePendingCreateCountRequest($params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getArticlePendingCreateCount'
     *
     * Parameters:
     *   "assigned_person" string   (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getArticlePendingCreateCountRequest(array $params = [])
    {
        if (!isset($params['assigned_person'])) {
            $params['assigned_person'] = null;
        }
        

        $resourcePath = '/article_pending_creates/counts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($params['assigned_person'] !== null) {
            $queryParams['assigned_person'] = ObjectSerializer::toQueryValue($params['assigned_person']);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getArticlePendingCreates
     *
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "assigned_person" string   (optional)
     *   "order_by" string  how to order result (optional)
     *   "order_dir" string  order direction (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getArticlePendingCreates(array $params = [])
    {
        list($response) = $this->getArticlePendingCreatesWithHttpInfo($params);
        return $response;
    }

    /**
     * Operation getArticlePendingCreatesWithHttpInfo
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "assigned_person" string   (optional)
     *   "order_by" string  how to order result (optional)
     *   "order_dir" string  order direction (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getArticlePendingCreatesWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getArticlePendingCreatesRequest($params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getArticlePendingCreatesAsync
     *
     * 
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "assigned_person" string   (optional)
     *   "order_by" string  how to order result (optional)
     *   "order_dir" string  order direction (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArticlePendingCreatesAsync(array $params = [])
    {
        return $this->getArticlePendingCreatesAsyncWithHttpInfo($params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getArticlePendingCreatesAsyncWithHttpInfo
     *
     * 
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "assigned_person" string   (optional)
     *   "order_by" string  how to order result (optional)
     *   "order_dir" string  order direction (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArticlePendingCreatesAsyncWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getArticlePendingCreatesRequest($params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getArticlePendingCreates'
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "assigned_person" string   (optional)
     *   "order_by" string  how to order result (optional)
     *   "order_dir" string  order direction (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getArticlePendingCreatesRequest(array $params = [])
    {
        if (!isset($params['page'])) {
            $params['page'] = null;
        }
        if (!isset($params['count'])) {
            $params['count'] = null;
        }
        if (!isset($params['limit'])) {
            $params['limit'] = null;
        }
        if (!isset($params['ids'])) {
            $params['ids'] = null;
        }
        if (!isset($params['assigned_person'])) {
            $params['assigned_person'] = null;
        }
        if (!isset($params['order_by'])) {
            $params['order_by'] = null;
        }
        if (!isset($params['order_dir'])) {
            $params['order_dir'] = null;
        }
        

        $resourcePath = '/article_pending_creates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($params['page'] !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($params['page']);
        }
        // query params
        if ($params['count'] !== null) {
            $queryParams['count'] = ObjectSerializer::toQueryValue($params['count']);
        }
        // query params
        if ($params['limit'] !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($params['limit']);
        }
        // query params
        if ($params['ids'] !== null) {
            $queryParams['ids'] = ObjectSerializer::toQueryValue($params['ids']);
        }
        // query params
        if ($params['assigned_person'] !== null) {
            $queryParams['assigned_person'] = ObjectSerializer::toQueryValue($params['assigned_person']);
        }
        // query params
        if ($params['order_by'] !== null) {
            $queryParams['order_by'] = ObjectSerializer::toQueryValue($params['order_by']);
        }
        // query params
        if ($params['order_dir'] !== null) {
            $queryParams['order_dir'] = ObjectSerializer::toQueryValue($params['order_dir']);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getArticles
     *
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group downloads (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *   "order_by" int  how to order (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getArticles(array $params = [])
    {
        list($response) = $this->getArticlesWithHttpInfo($params);
        return $response;
    }

    /**
     * Operation getArticlesWithHttpInfo
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group downloads (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *   "order_by" int  how to order (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getArticlesWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getArticlesRequest($params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getArticlesAsync
     *
     * 
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group downloads (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *   "order_by" int  how to order (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArticlesAsync(array $params = [])
    {
        return $this->getArticlesAsyncWithHttpInfo($params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getArticlesAsyncWithHttpInfo
     *
     * 
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group downloads (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *   "order_by" int  how to order (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArticlesAsyncWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getArticlesRequest($params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getArticles'
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group downloads (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *   "order_by" int  how to order (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getArticlesRequest(array $params = [])
    {
        if (!isset($params['page'])) {
            $params['page'] = null;
        }
        if (!isset($params['count'])) {
            $params['count'] = null;
        }
        if (!isset($params['limit'])) {
            $params['limit'] = null;
        }
        if (!isset($params['ids'])) {
            $params['ids'] = null;
        }
        if (!isset($params['author'])) {
            $params['author'] = null;
        }
        if (!isset($params['category'])) {
            $params['category'] = null;
        }
        if (!isset($params['group_by'])) {
            $params['group_by'] = null;
        }
        if (!isset($params['status'])) {
            $params['status'] = null;
        }
        if (!isset($params['hidden_status'])) {
            $params['hidden_status'] = null;
        }
        if (!isset($params['period_created'])) {
            $params['period_created'] = null;
        }
        if (!isset($params['period_last_comment'])) {
            $params['period_last_comment'] = null;
        }
        if (!isset($params['period_published'])) {
            $params['period_published'] = null;
        }
        if (!isset($params['period_updated'])) {
            $params['period_updated'] = null;
        }
        if (!isset($params['order_by'])) {
            $params['order_by'] = null;
        }
        

        $resourcePath = '/articles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($params['page'] !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($params['page']);
        }
        // query params
        if ($params['count'] !== null) {
            $queryParams['count'] = ObjectSerializer::toQueryValue($params['count']);
        }
        // query params
        if ($params['limit'] !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($params['limit']);
        }
        // query params
        if ($params['ids'] !== null) {
            $queryParams['ids'] = ObjectSerializer::toQueryValue($params['ids']);
        }
        // query params
        if ($params['author'] !== null) {
            $queryParams['author'] = ObjectSerializer::toQueryValue($params['author']);
        }
        // query params
        if ($params['category'] !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($params['category']);
        }
        // query params
        if ($params['group_by'] !== null) {
            $queryParams['group_by'] = ObjectSerializer::toQueryValue($params['group_by']);
        }
        // query params
        if ($params['status'] !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($params['status']);
        }
        // query params
        if ($params['hidden_status'] !== null) {
            $queryParams['hidden_status'] = ObjectSerializer::toQueryValue($params['hidden_status']);
        }
        // query params
        if ($params['period_created'] !== null) {
            $queryParams['period_created'] = ObjectSerializer::toQueryValue($params['period_created']);
        }
        // query params
        if ($params['period_last_comment'] !== null) {
            $queryParams['period_last_comment'] = ObjectSerializer::toQueryValue($params['period_last_comment']);
        }
        // query params
        if ($params['period_published'] !== null) {
            $queryParams['period_published'] = ObjectSerializer::toQueryValue($params['period_published']);
        }
        // query params
        if ($params['period_updated'] !== null) {
            $queryParams['period_updated'] = ObjectSerializer::toQueryValue($params['period_updated']);
        }
        // query params
        if ($params['order_by'] !== null) {
            $queryParams['order_by'] = ObjectSerializer::toQueryValue($params['order_by']);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getContentCategories
     *
     *
     * Parameters:
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getContentCategories(array $params = [])
    {
        list($response) = $this->getContentCategoriesWithHttpInfo($params);
        return $response;
    }

    /**
     * Operation getContentCategoriesWithHttpInfo
     *
     * Parameters:
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getContentCategoriesWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getContentCategoriesRequest($params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getContentCategoriesAsync
     *
     * 
     *
     * Parameters:
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getContentCategoriesAsync(array $params = [])
    {
        return $this->getContentCategoriesAsyncWithHttpInfo($params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getContentCategoriesAsyncWithHttpInfo
     *
     * 
     *
     * Parameters:
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getContentCategoriesAsyncWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getContentCategoriesRequest($params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getContentCategories'
     *
     * Parameters:
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getContentCategoriesRequest(array $params = [])
    {
        

        $resourcePath = '/content_categories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDownloadById
     *
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getDownloadById(array $params = [])
    {
        list($response) = $this->getDownloadByIdWithHttpInfo($params);
        return $response;
    }

    /**
     * Operation getDownloadByIdWithHttpInfo
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDownloadByIdWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getDownloadByIdRequest($params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDownloadByIdAsync
     *
     * 
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDownloadByIdAsync(array $params = [])
    {
        return $this->getDownloadByIdAsyncWithHttpInfo($params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDownloadByIdAsyncWithHttpInfo
     *
     * 
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDownloadByIdAsyncWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getDownloadByIdRequest($params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDownloadById'
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDownloadByIdRequest(array $params = [])
    {
        if (empty($params['id'])) {
            throw new \InvalidArgumentException('Missing parameter "id" in ContentApi::getDownloadByIdRequest().');
        }
        

        $resourcePath = '/downloads/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($params['id'] !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($params['id']),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDownloadCategories
     *
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getDownloadCategories(array $params = [])
    {
        list($response) = $this->getDownloadCategoriesWithHttpInfo($params);
        return $response;
    }

    /**
     * Operation getDownloadCategoriesWithHttpInfo
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDownloadCategoriesWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getDownloadCategoriesRequest($params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDownloadCategoriesAsync
     *
     * 
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDownloadCategoriesAsync(array $params = [])
    {
        return $this->getDownloadCategoriesAsyncWithHttpInfo($params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDownloadCategoriesAsyncWithHttpInfo
     *
     * 
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDownloadCategoriesAsyncWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getDownloadCategoriesRequest($params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDownloadCategories'
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDownloadCategoriesRequest(array $params = [])
    {
        if (!isset($params['page'])) {
            $params['page'] = null;
        }
        if (!isset($params['count'])) {
            $params['count'] = null;
        }
        if (!isset($params['limit'])) {
            $params['limit'] = null;
        }
        if (!isset($params['ids'])) {
            $params['ids'] = null;
        }
        

        $resourcePath = '/download_categories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($params['page'] !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($params['page']);
        }
        // query params
        if ($params['count'] !== null) {
            $queryParams['count'] = ObjectSerializer::toQueryValue($params['count']);
        }
        // query params
        if ($params['limit'] !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($params['limit']);
        }
        // query params
        if ($params['ids'] !== null) {
            $queryParams['ids'] = ObjectSerializer::toQueryValue($params['ids']);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDownloadCategoryById
     *
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getDownloadCategoryById(array $params = [])
    {
        list($response) = $this->getDownloadCategoryByIdWithHttpInfo($params);
        return $response;
    }

    /**
     * Operation getDownloadCategoryByIdWithHttpInfo
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDownloadCategoryByIdWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getDownloadCategoryByIdRequest($params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDownloadCategoryByIdAsync
     *
     * 
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDownloadCategoryByIdAsync(array $params = [])
    {
        return $this->getDownloadCategoryByIdAsyncWithHttpInfo($params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDownloadCategoryByIdAsyncWithHttpInfo
     *
     * 
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDownloadCategoryByIdAsyncWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getDownloadCategoryByIdRequest($params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDownloadCategoryById'
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDownloadCategoryByIdRequest(array $params = [])
    {
        if (empty($params['id'])) {
            throw new \InvalidArgumentException('Missing parameter "id" in ContentApi::getDownloadCategoryByIdRequest().');
        }
        

        $resourcePath = '/download_categories/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($params['id'] !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($params['id']),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDownloadCategoryCount
     *
     *
     * Parameters:
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getDownloadCategoryCount(array $params = [])
    {
        list($response) = $this->getDownloadCategoryCountWithHttpInfo($params);
        return $response;
    }

    /**
     * Operation getDownloadCategoryCountWithHttpInfo
     *
     * Parameters:
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDownloadCategoryCountWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getDownloadCategoryCountRequest($params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDownloadCategoryCountAsync
     *
     * 
     *
     * Parameters:
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDownloadCategoryCountAsync(array $params = [])
    {
        return $this->getDownloadCategoryCountAsyncWithHttpInfo($params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDownloadCategoryCountAsyncWithHttpInfo
     *
     * 
     *
     * Parameters:
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDownloadCategoryCountAsyncWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getDownloadCategoryCountRequest($params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDownloadCategoryCount'
     *
     * Parameters:
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDownloadCategoryCountRequest(array $params = [])
    {
        

        $resourcePath = '/download_categories/counts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDownloadCommentById
     *
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getDownloadCommentById(array $params = [])
    {
        list($response) = $this->getDownloadCommentByIdWithHttpInfo($params);
        return $response;
    }

    /**
     * Operation getDownloadCommentByIdWithHttpInfo
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDownloadCommentByIdWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getDownloadCommentByIdRequest($params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDownloadCommentByIdAsync
     *
     * 
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDownloadCommentByIdAsync(array $params = [])
    {
        return $this->getDownloadCommentByIdAsyncWithHttpInfo($params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDownloadCommentByIdAsyncWithHttpInfo
     *
     * 
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDownloadCommentByIdAsyncWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getDownloadCommentByIdRequest($params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDownloadCommentById'
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDownloadCommentByIdRequest(array $params = [])
    {
        if (empty($params['id'])) {
            throw new \InvalidArgumentException('Missing parameter "id" in ContentApi::getDownloadCommentByIdRequest().');
        }
        

        $resourcePath = '/download_comments/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($params['id'] !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($params['id']),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDownloadCommentCount
     *
     *
     * Parameters:
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "group_by" string  how to groups comments (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getDownloadCommentCount(array $params = [])
    {
        list($response) = $this->getDownloadCommentCountWithHttpInfo($params);
        return $response;
    }

    /**
     * Operation getDownloadCommentCountWithHttpInfo
     *
     * Parameters:
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "group_by" string  how to groups comments (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDownloadCommentCountWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getDownloadCommentCountRequest($params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDownloadCommentCountAsync
     *
     * 
     *
     * Parameters:
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "group_by" string  how to groups comments (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDownloadCommentCountAsync(array $params = [])
    {
        return $this->getDownloadCommentCountAsyncWithHttpInfo($params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDownloadCommentCountAsyncWithHttpInfo
     *
     * 
     *
     * Parameters:
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "group_by" string  how to groups comments (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDownloadCommentCountAsyncWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getDownloadCommentCountRequest($params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDownloadCommentCount'
     *
     * Parameters:
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "group_by" string  how to groups comments (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDownloadCommentCountRequest(array $params = [])
    {
        if (!isset($params['status'])) {
            $params['status'] = null;
        }
        if (!isset($params['is_reviewed'])) {
            $params['is_reviewed'] = null;
        }
        if (!isset($params['period_created'])) {
            $params['period_created'] = null;
        }
        if (!isset($params['article'])) {
            $params['article'] = null;
        }
        if (!isset($params['download'])) {
            $params['download'] = null;
        }
        if (!isset($params['news'])) {
            $params['news'] = null;
        }
        if (!isset($params['group_by'])) {
            $params['group_by'] = null;
        }
        

        $resourcePath = '/download_comments/counts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($params['status'] !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($params['status']);
        }
        // query params
        if ($params['is_reviewed'] !== null) {
            $queryParams['is_reviewed'] = ObjectSerializer::toQueryValue($params['is_reviewed']);
        }
        // query params
        if ($params['period_created'] !== null) {
            $queryParams['period_created'] = ObjectSerializer::toQueryValue($params['period_created']);
        }
        // query params
        if ($params['article'] !== null) {
            $queryParams['article'] = ObjectSerializer::toQueryValue($params['article']);
        }
        // query params
        if ($params['download'] !== null) {
            $queryParams['download'] = ObjectSerializer::toQueryValue($params['download']);
        }
        // query params
        if ($params['news'] !== null) {
            $queryParams['news'] = ObjectSerializer::toQueryValue($params['news']);
        }
        // query params
        if ($params['group_by'] !== null) {
            $queryParams['group_by'] = ObjectSerializer::toQueryValue($params['group_by']);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDownloadComments
     *
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "order_by" string  how to order comments (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getDownloadComments(array $params = [])
    {
        list($response) = $this->getDownloadCommentsWithHttpInfo($params);
        return $response;
    }

    /**
     * Operation getDownloadCommentsWithHttpInfo
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "order_by" string  how to order comments (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDownloadCommentsWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getDownloadCommentsRequest($params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDownloadCommentsAsync
     *
     * 
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "order_by" string  how to order comments (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDownloadCommentsAsync(array $params = [])
    {
        return $this->getDownloadCommentsAsyncWithHttpInfo($params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDownloadCommentsAsyncWithHttpInfo
     *
     * 
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "order_by" string  how to order comments (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDownloadCommentsAsyncWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getDownloadCommentsRequest($params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDownloadComments'
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "order_by" string  how to order comments (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDownloadCommentsRequest(array $params = [])
    {
        if (!isset($params['page'])) {
            $params['page'] = null;
        }
        if (!isset($params['count'])) {
            $params['count'] = null;
        }
        if (!isset($params['limit'])) {
            $params['limit'] = null;
        }
        if (!isset($params['ids'])) {
            $params['ids'] = null;
        }
        if (!isset($params['status'])) {
            $params['status'] = null;
        }
        if (!isset($params['is_reviewed'])) {
            $params['is_reviewed'] = null;
        }
        if (!isset($params['period_created'])) {
            $params['period_created'] = null;
        }
        if (!isset($params['article'])) {
            $params['article'] = null;
        }
        if (!isset($params['download'])) {
            $params['download'] = null;
        }
        if (!isset($params['news'])) {
            $params['news'] = null;
        }
        if (!isset($params['order_by'])) {
            $params['order_by'] = null;
        }
        

        $resourcePath = '/download_comments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($params['page'] !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($params['page']);
        }
        // query params
        if ($params['count'] !== null) {
            $queryParams['count'] = ObjectSerializer::toQueryValue($params['count']);
        }
        // query params
        if ($params['limit'] !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($params['limit']);
        }
        // query params
        if ($params['ids'] !== null) {
            $queryParams['ids'] = ObjectSerializer::toQueryValue($params['ids']);
        }
        // query params
        if ($params['status'] !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($params['status']);
        }
        // query params
        if ($params['is_reviewed'] !== null) {
            $queryParams['is_reviewed'] = ObjectSerializer::toQueryValue($params['is_reviewed']);
        }
        // query params
        if ($params['period_created'] !== null) {
            $queryParams['period_created'] = ObjectSerializer::toQueryValue($params['period_created']);
        }
        // query params
        if ($params['article'] !== null) {
            $queryParams['article'] = ObjectSerializer::toQueryValue($params['article']);
        }
        // query params
        if ($params['download'] !== null) {
            $queryParams['download'] = ObjectSerializer::toQueryValue($params['download']);
        }
        // query params
        if ($params['news'] !== null) {
            $queryParams['news'] = ObjectSerializer::toQueryValue($params['news']);
        }
        // query params
        if ($params['order_by'] !== null) {
            $queryParams['order_by'] = ObjectSerializer::toQueryValue($params['order_by']);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDownloadCount
     *
     *
     * Parameters:
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group counters (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getDownloadCount(array $params = [])
    {
        list($response) = $this->getDownloadCountWithHttpInfo($params);
        return $response;
    }

    /**
     * Operation getDownloadCountWithHttpInfo
     *
     * Parameters:
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group counters (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDownloadCountWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getDownloadCountRequest($params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDownloadCountAsync
     *
     * 
     *
     * Parameters:
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group counters (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDownloadCountAsync(array $params = [])
    {
        return $this->getDownloadCountAsyncWithHttpInfo($params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDownloadCountAsyncWithHttpInfo
     *
     * 
     *
     * Parameters:
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group counters (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDownloadCountAsyncWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getDownloadCountRequest($params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDownloadCount'
     *
     * Parameters:
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group counters (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDownloadCountRequest(array $params = [])
    {
        if (!isset($params['author'])) {
            $params['author'] = null;
        }
        if (!isset($params['category'])) {
            $params['category'] = null;
        }
        if (!isset($params['group_by'])) {
            $params['group_by'] = null;
        }
        if (!isset($params['status'])) {
            $params['status'] = null;
        }
        if (!isset($params['hidden_status'])) {
            $params['hidden_status'] = null;
        }
        if (!isset($params['period_created'])) {
            $params['period_created'] = null;
        }
        if (!isset($params['period_last_comment'])) {
            $params['period_last_comment'] = null;
        }
        if (!isset($params['period_published'])) {
            $params['period_published'] = null;
        }
        if (!isset($params['period_updated'])) {
            $params['period_updated'] = null;
        }
        

        $resourcePath = '/downloads/counts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($params['author'] !== null) {
            $queryParams['author'] = ObjectSerializer::toQueryValue($params['author']);
        }
        // query params
        if ($params['category'] !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($params['category']);
        }
        // query params
        if ($params['group_by'] !== null) {
            $queryParams['group_by'] = ObjectSerializer::toQueryValue($params['group_by']);
        }
        // query params
        if ($params['status'] !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($params['status']);
        }
        // query params
        if ($params['hidden_status'] !== null) {
            $queryParams['hidden_status'] = ObjectSerializer::toQueryValue($params['hidden_status']);
        }
        // query params
        if ($params['period_created'] !== null) {
            $queryParams['period_created'] = ObjectSerializer::toQueryValue($params['period_created']);
        }
        // query params
        if ($params['period_last_comment'] !== null) {
            $queryParams['period_last_comment'] = ObjectSerializer::toQueryValue($params['period_last_comment']);
        }
        // query params
        if ($params['period_published'] !== null) {
            $queryParams['period_published'] = ObjectSerializer::toQueryValue($params['period_published']);
        }
        // query params
        if ($params['period_updated'] !== null) {
            $queryParams['period_updated'] = ObjectSerializer::toQueryValue($params['period_updated']);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDownloads
     *
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group downloads (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *   "order_by" int  how to order (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getDownloads(array $params = [])
    {
        list($response) = $this->getDownloadsWithHttpInfo($params);
        return $response;
    }

    /**
     * Operation getDownloadsWithHttpInfo
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group downloads (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *   "order_by" int  how to order (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDownloadsWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getDownloadsRequest($params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDownloadsAsync
     *
     * 
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group downloads (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *   "order_by" int  how to order (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDownloadsAsync(array $params = [])
    {
        return $this->getDownloadsAsyncWithHttpInfo($params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDownloadsAsyncWithHttpInfo
     *
     * 
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group downloads (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *   "order_by" int  how to order (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDownloadsAsyncWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getDownloadsRequest($params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDownloads'
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group downloads (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *   "order_by" int  how to order (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDownloadsRequest(array $params = [])
    {
        if (!isset($params['page'])) {
            $params['page'] = null;
        }
        if (!isset($params['count'])) {
            $params['count'] = null;
        }
        if (!isset($params['limit'])) {
            $params['limit'] = null;
        }
        if (!isset($params['ids'])) {
            $params['ids'] = null;
        }
        if (!isset($params['author'])) {
            $params['author'] = null;
        }
        if (!isset($params['category'])) {
            $params['category'] = null;
        }
        if (!isset($params['group_by'])) {
            $params['group_by'] = null;
        }
        if (!isset($params['status'])) {
            $params['status'] = null;
        }
        if (!isset($params['hidden_status'])) {
            $params['hidden_status'] = null;
        }
        if (!isset($params['period_created'])) {
            $params['period_created'] = null;
        }
        if (!isset($params['period_last_comment'])) {
            $params['period_last_comment'] = null;
        }
        if (!isset($params['period_published'])) {
            $params['period_published'] = null;
        }
        if (!isset($params['period_updated'])) {
            $params['period_updated'] = null;
        }
        if (!isset($params['order_by'])) {
            $params['order_by'] = null;
        }
        

        $resourcePath = '/downloads';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($params['page'] !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($params['page']);
        }
        // query params
        if ($params['count'] !== null) {
            $queryParams['count'] = ObjectSerializer::toQueryValue($params['count']);
        }
        // query params
        if ($params['limit'] !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($params['limit']);
        }
        // query params
        if ($params['ids'] !== null) {
            $queryParams['ids'] = ObjectSerializer::toQueryValue($params['ids']);
        }
        // query params
        if ($params['author'] !== null) {
            $queryParams['author'] = ObjectSerializer::toQueryValue($params['author']);
        }
        // query params
        if ($params['category'] !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($params['category']);
        }
        // query params
        if ($params['group_by'] !== null) {
            $queryParams['group_by'] = ObjectSerializer::toQueryValue($params['group_by']);
        }
        // query params
        if ($params['status'] !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($params['status']);
        }
        // query params
        if ($params['hidden_status'] !== null) {
            $queryParams['hidden_status'] = ObjectSerializer::toQueryValue($params['hidden_status']);
        }
        // query params
        if ($params['period_created'] !== null) {
            $queryParams['period_created'] = ObjectSerializer::toQueryValue($params['period_created']);
        }
        // query params
        if ($params['period_last_comment'] !== null) {
            $queryParams['period_last_comment'] = ObjectSerializer::toQueryValue($params['period_last_comment']);
        }
        // query params
        if ($params['period_published'] !== null) {
            $queryParams['period_published'] = ObjectSerializer::toQueryValue($params['period_published']);
        }
        // query params
        if ($params['period_updated'] !== null) {
            $queryParams['period_updated'] = ObjectSerializer::toQueryValue($params['period_updated']);
        }
        // query params
        if ($params['order_by'] !== null) {
            $queryParams['order_by'] = ObjectSerializer::toQueryValue($params['order_by']);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGuideByGuideIdExport
     *
     *
     * Parameters:
     *   "guide_id" string   (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getGuideByGuideIdExport(array $params = [])
    {
        list($response) = $this->getGuideByGuideIdExportWithHttpInfo($params);
        return $response;
    }

    /**
     * Operation getGuideByGuideIdExportWithHttpInfo
     *
     * Parameters:
     *   "guide_id" string   (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGuideByGuideIdExportWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getGuideByGuideIdExportRequest($params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getGuideByGuideIdExportAsync
     *
     * 
     *
     * Parameters:
     *   "guide_id" string   (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGuideByGuideIdExportAsync(array $params = [])
    {
        return $this->getGuideByGuideIdExportAsyncWithHttpInfo($params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGuideByGuideIdExportAsyncWithHttpInfo
     *
     * 
     *
     * Parameters:
     *   "guide_id" string   (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGuideByGuideIdExportAsyncWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getGuideByGuideIdExportRequest($params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGuideByGuideIdExport'
     *
     * Parameters:
     *   "guide_id" string   (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getGuideByGuideIdExportRequest(array $params = [])
    {
        if (empty($params['guide_id'])) {
            throw new \InvalidArgumentException('Missing parameter "guide_id" in ContentApi::getGuideByGuideIdExportRequest().');
        }
        

        $resourcePath = '/guides/{guideId}/export';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($params['guide_id'] !== null) {
            $resourcePath = str_replace(
                '{' . 'guideId' . '}',
                ObjectSerializer::toPathValue($params['guide_id']),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGuideByGuideIdTree
     *
     *
     * Parameters:
     *   "guide_id" string   (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getGuideByGuideIdTree(array $params = [])
    {
        list($response) = $this->getGuideByGuideIdTreeWithHttpInfo($params);
        return $response;
    }

    /**
     * Operation getGuideByGuideIdTreeWithHttpInfo
     *
     * Parameters:
     *   "guide_id" string   (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGuideByGuideIdTreeWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getGuideByGuideIdTreeRequest($params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getGuideByGuideIdTreeAsync
     *
     * 
     *
     * Parameters:
     *   "guide_id" string   (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGuideByGuideIdTreeAsync(array $params = [])
    {
        return $this->getGuideByGuideIdTreeAsyncWithHttpInfo($params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGuideByGuideIdTreeAsyncWithHttpInfo
     *
     * 
     *
     * Parameters:
     *   "guide_id" string   (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGuideByGuideIdTreeAsyncWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getGuideByGuideIdTreeRequest($params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGuideByGuideIdTree'
     *
     * Parameters:
     *   "guide_id" string   (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getGuideByGuideIdTreeRequest(array $params = [])
    {
        if (empty($params['guide_id'])) {
            throw new \InvalidArgumentException('Missing parameter "guide_id" in ContentApi::getGuideByGuideIdTreeRequest().');
        }
        

        $resourcePath = '/guides/{guideId}/tree';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($params['guide_id'] !== null) {
            $resourcePath = str_replace(
                '{' . 'guideId' . '}',
                ObjectSerializer::toPathValue($params['guide_id']),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGuideById
     *
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getGuideById(array $params = [])
    {
        list($response) = $this->getGuideByIdWithHttpInfo($params);
        return $response;
    }

    /**
     * Operation getGuideByIdWithHttpInfo
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGuideByIdWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getGuideByIdRequest($params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getGuideByIdAsync
     *
     * 
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGuideByIdAsync(array $params = [])
    {
        return $this->getGuideByIdAsyncWithHttpInfo($params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGuideByIdAsyncWithHttpInfo
     *
     * 
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGuideByIdAsyncWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getGuideByIdRequest($params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGuideById'
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getGuideByIdRequest(array $params = [])
    {
        if (empty($params['id'])) {
            throw new \InvalidArgumentException('Missing parameter "id" in ContentApi::getGuideByIdRequest().');
        }
        

        $resourcePath = '/guides/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($params['id'] !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($params['id']),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGuideCount
     *
     *
     * Parameters:
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getGuideCount(array $params = [])
    {
        list($response) = $this->getGuideCountWithHttpInfo($params);
        return $response;
    }

    /**
     * Operation getGuideCountWithHttpInfo
     *
     * Parameters:
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGuideCountWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getGuideCountRequest($params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getGuideCountAsync
     *
     * 
     *
     * Parameters:
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGuideCountAsync(array $params = [])
    {
        return $this->getGuideCountAsyncWithHttpInfo($params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGuideCountAsyncWithHttpInfo
     *
     * 
     *
     * Parameters:
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGuideCountAsyncWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getGuideCountRequest($params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGuideCount'
     *
     * Parameters:
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getGuideCountRequest(array $params = [])
    {
        

        $resourcePath = '/guides/counts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGuides
     *
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getGuides(array $params = [])
    {
        list($response) = $this->getGuidesWithHttpInfo($params);
        return $response;
    }

    /**
     * Operation getGuidesWithHttpInfo
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGuidesWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getGuidesRequest($params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getGuidesAsync
     *
     * 
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGuidesAsync(array $params = [])
    {
        return $this->getGuidesAsyncWithHttpInfo($params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGuidesAsyncWithHttpInfo
     *
     * 
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGuidesAsyncWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getGuidesRequest($params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGuides'
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getGuidesRequest(array $params = [])
    {
        if (!isset($params['page'])) {
            $params['page'] = null;
        }
        if (!isset($params['count'])) {
            $params['count'] = null;
        }
        if (!isset($params['limit'])) {
            $params['limit'] = null;
        }
        if (!isset($params['ids'])) {
            $params['ids'] = null;
        }
        

        $resourcePath = '/guides';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($params['page'] !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($params['page']);
        }
        // query params
        if ($params['count'] !== null) {
            $queryParams['count'] = ObjectSerializer::toQueryValue($params['count']);
        }
        // query params
        if ($params['limit'] !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($params['limit']);
        }
        // query params
        if ($params['ids'] !== null) {
            $queryParams['ids'] = ObjectSerializer::toQueryValue($params['ids']);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNews
     *
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group downloads (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *   "order_by" int  how to order (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getNews(array $params = [])
    {
        list($response) = $this->getNewsWithHttpInfo($params);
        return $response;
    }

    /**
     * Operation getNewsWithHttpInfo
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group downloads (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *   "order_by" int  how to order (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNewsWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getNewsRequest($params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNewsAsync
     *
     * 
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group downloads (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *   "order_by" int  how to order (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNewsAsync(array $params = [])
    {
        return $this->getNewsAsyncWithHttpInfo($params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNewsAsyncWithHttpInfo
     *
     * 
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group downloads (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *   "order_by" int  how to order (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNewsAsyncWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getNewsRequest($params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNews'
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group downloads (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *   "order_by" int  how to order (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNewsRequest(array $params = [])
    {
        if (!isset($params['page'])) {
            $params['page'] = null;
        }
        if (!isset($params['count'])) {
            $params['count'] = null;
        }
        if (!isset($params['limit'])) {
            $params['limit'] = null;
        }
        if (!isset($params['ids'])) {
            $params['ids'] = null;
        }
        if (!isset($params['author'])) {
            $params['author'] = null;
        }
        if (!isset($params['category'])) {
            $params['category'] = null;
        }
        if (!isset($params['group_by'])) {
            $params['group_by'] = null;
        }
        if (!isset($params['status'])) {
            $params['status'] = null;
        }
        if (!isset($params['hidden_status'])) {
            $params['hidden_status'] = null;
        }
        if (!isset($params['period_created'])) {
            $params['period_created'] = null;
        }
        if (!isset($params['period_last_comment'])) {
            $params['period_last_comment'] = null;
        }
        if (!isset($params['period_published'])) {
            $params['period_published'] = null;
        }
        if (!isset($params['period_updated'])) {
            $params['period_updated'] = null;
        }
        if (!isset($params['order_by'])) {
            $params['order_by'] = null;
        }
        

        $resourcePath = '/news';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($params['page'] !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($params['page']);
        }
        // query params
        if ($params['count'] !== null) {
            $queryParams['count'] = ObjectSerializer::toQueryValue($params['count']);
        }
        // query params
        if ($params['limit'] !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($params['limit']);
        }
        // query params
        if ($params['ids'] !== null) {
            $queryParams['ids'] = ObjectSerializer::toQueryValue($params['ids']);
        }
        // query params
        if ($params['author'] !== null) {
            $queryParams['author'] = ObjectSerializer::toQueryValue($params['author']);
        }
        // query params
        if ($params['category'] !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($params['category']);
        }
        // query params
        if ($params['group_by'] !== null) {
            $queryParams['group_by'] = ObjectSerializer::toQueryValue($params['group_by']);
        }
        // query params
        if ($params['status'] !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($params['status']);
        }
        // query params
        if ($params['hidden_status'] !== null) {
            $queryParams['hidden_status'] = ObjectSerializer::toQueryValue($params['hidden_status']);
        }
        // query params
        if ($params['period_created'] !== null) {
            $queryParams['period_created'] = ObjectSerializer::toQueryValue($params['period_created']);
        }
        // query params
        if ($params['period_last_comment'] !== null) {
            $queryParams['period_last_comment'] = ObjectSerializer::toQueryValue($params['period_last_comment']);
        }
        // query params
        if ($params['period_published'] !== null) {
            $queryParams['period_published'] = ObjectSerializer::toQueryValue($params['period_published']);
        }
        // query params
        if ($params['period_updated'] !== null) {
            $queryParams['period_updated'] = ObjectSerializer::toQueryValue($params['period_updated']);
        }
        // query params
        if ($params['order_by'] !== null) {
            $queryParams['order_by'] = ObjectSerializer::toQueryValue($params['order_by']);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNewsById
     *
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getNewsById(array $params = [])
    {
        list($response) = $this->getNewsByIdWithHttpInfo($params);
        return $response;
    }

    /**
     * Operation getNewsByIdWithHttpInfo
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNewsByIdWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getNewsByIdRequest($params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNewsByIdAsync
     *
     * 
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNewsByIdAsync(array $params = [])
    {
        return $this->getNewsByIdAsyncWithHttpInfo($params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNewsByIdAsyncWithHttpInfo
     *
     * 
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNewsByIdAsyncWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getNewsByIdRequest($params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNewsById'
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNewsByIdRequest(array $params = [])
    {
        if (empty($params['id'])) {
            throw new \InvalidArgumentException('Missing parameter "id" in ContentApi::getNewsByIdRequest().');
        }
        

        $resourcePath = '/news/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($params['id'] !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($params['id']),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNewsCategories
     *
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getNewsCategories(array $params = [])
    {
        list($response) = $this->getNewsCategoriesWithHttpInfo($params);
        return $response;
    }

    /**
     * Operation getNewsCategoriesWithHttpInfo
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNewsCategoriesWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getNewsCategoriesRequest($params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNewsCategoriesAsync
     *
     * 
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNewsCategoriesAsync(array $params = [])
    {
        return $this->getNewsCategoriesAsyncWithHttpInfo($params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNewsCategoriesAsyncWithHttpInfo
     *
     * 
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNewsCategoriesAsyncWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getNewsCategoriesRequest($params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNewsCategories'
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNewsCategoriesRequest(array $params = [])
    {
        if (!isset($params['page'])) {
            $params['page'] = null;
        }
        if (!isset($params['count'])) {
            $params['count'] = null;
        }
        if (!isset($params['limit'])) {
            $params['limit'] = null;
        }
        if (!isset($params['ids'])) {
            $params['ids'] = null;
        }
        

        $resourcePath = '/news_categories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($params['page'] !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($params['page']);
        }
        // query params
        if ($params['count'] !== null) {
            $queryParams['count'] = ObjectSerializer::toQueryValue($params['count']);
        }
        // query params
        if ($params['limit'] !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($params['limit']);
        }
        // query params
        if ($params['ids'] !== null) {
            $queryParams['ids'] = ObjectSerializer::toQueryValue($params['ids']);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNewsCategoryById
     *
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getNewsCategoryById(array $params = [])
    {
        list($response) = $this->getNewsCategoryByIdWithHttpInfo($params);
        return $response;
    }

    /**
     * Operation getNewsCategoryByIdWithHttpInfo
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNewsCategoryByIdWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getNewsCategoryByIdRequest($params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNewsCategoryByIdAsync
     *
     * 
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNewsCategoryByIdAsync(array $params = [])
    {
        return $this->getNewsCategoryByIdAsyncWithHttpInfo($params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNewsCategoryByIdAsyncWithHttpInfo
     *
     * 
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNewsCategoryByIdAsyncWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getNewsCategoryByIdRequest($params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNewsCategoryById'
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNewsCategoryByIdRequest(array $params = [])
    {
        if (empty($params['id'])) {
            throw new \InvalidArgumentException('Missing parameter "id" in ContentApi::getNewsCategoryByIdRequest().');
        }
        

        $resourcePath = '/news_categories/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($params['id'] !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($params['id']),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNewsCategoryCount
     *
     *
     * Parameters:
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getNewsCategoryCount(array $params = [])
    {
        list($response) = $this->getNewsCategoryCountWithHttpInfo($params);
        return $response;
    }

    /**
     * Operation getNewsCategoryCountWithHttpInfo
     *
     * Parameters:
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNewsCategoryCountWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getNewsCategoryCountRequest($params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNewsCategoryCountAsync
     *
     * 
     *
     * Parameters:
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNewsCategoryCountAsync(array $params = [])
    {
        return $this->getNewsCategoryCountAsyncWithHttpInfo($params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNewsCategoryCountAsyncWithHttpInfo
     *
     * 
     *
     * Parameters:
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNewsCategoryCountAsyncWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getNewsCategoryCountRequest($params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNewsCategoryCount'
     *
     * Parameters:
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNewsCategoryCountRequest(array $params = [])
    {
        

        $resourcePath = '/news_categories/counts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNewsCommentById
     *
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getNewsCommentById(array $params = [])
    {
        list($response) = $this->getNewsCommentByIdWithHttpInfo($params);
        return $response;
    }

    /**
     * Operation getNewsCommentByIdWithHttpInfo
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNewsCommentByIdWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getNewsCommentByIdRequest($params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNewsCommentByIdAsync
     *
     * 
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNewsCommentByIdAsync(array $params = [])
    {
        return $this->getNewsCommentByIdAsyncWithHttpInfo($params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNewsCommentByIdAsyncWithHttpInfo
     *
     * 
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNewsCommentByIdAsyncWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getNewsCommentByIdRequest($params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNewsCommentById'
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNewsCommentByIdRequest(array $params = [])
    {
        if (empty($params['id'])) {
            throw new \InvalidArgumentException('Missing parameter "id" in ContentApi::getNewsCommentByIdRequest().');
        }
        

        $resourcePath = '/news_comments/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($params['id'] !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($params['id']),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNewsCommentCount
     *
     *
     * Parameters:
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "group_by" string  how to groups comments (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getNewsCommentCount(array $params = [])
    {
        list($response) = $this->getNewsCommentCountWithHttpInfo($params);
        return $response;
    }

    /**
     * Operation getNewsCommentCountWithHttpInfo
     *
     * Parameters:
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "group_by" string  how to groups comments (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNewsCommentCountWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getNewsCommentCountRequest($params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNewsCommentCountAsync
     *
     * 
     *
     * Parameters:
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "group_by" string  how to groups comments (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNewsCommentCountAsync(array $params = [])
    {
        return $this->getNewsCommentCountAsyncWithHttpInfo($params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNewsCommentCountAsyncWithHttpInfo
     *
     * 
     *
     * Parameters:
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "group_by" string  how to groups comments (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNewsCommentCountAsyncWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getNewsCommentCountRequest($params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNewsCommentCount'
     *
     * Parameters:
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "group_by" string  how to groups comments (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNewsCommentCountRequest(array $params = [])
    {
        if (!isset($params['status'])) {
            $params['status'] = null;
        }
        if (!isset($params['is_reviewed'])) {
            $params['is_reviewed'] = null;
        }
        if (!isset($params['period_created'])) {
            $params['period_created'] = null;
        }
        if (!isset($params['article'])) {
            $params['article'] = null;
        }
        if (!isset($params['download'])) {
            $params['download'] = null;
        }
        if (!isset($params['news'])) {
            $params['news'] = null;
        }
        if (!isset($params['group_by'])) {
            $params['group_by'] = null;
        }
        

        $resourcePath = '/news_comments/counts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($params['status'] !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($params['status']);
        }
        // query params
        if ($params['is_reviewed'] !== null) {
            $queryParams['is_reviewed'] = ObjectSerializer::toQueryValue($params['is_reviewed']);
        }
        // query params
        if ($params['period_created'] !== null) {
            $queryParams['period_created'] = ObjectSerializer::toQueryValue($params['period_created']);
        }
        // query params
        if ($params['article'] !== null) {
            $queryParams['article'] = ObjectSerializer::toQueryValue($params['article']);
        }
        // query params
        if ($params['download'] !== null) {
            $queryParams['download'] = ObjectSerializer::toQueryValue($params['download']);
        }
        // query params
        if ($params['news'] !== null) {
            $queryParams['news'] = ObjectSerializer::toQueryValue($params['news']);
        }
        // query params
        if ($params['group_by'] !== null) {
            $queryParams['group_by'] = ObjectSerializer::toQueryValue($params['group_by']);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNewsComments
     *
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "order_by" string  how to order comments (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getNewsComments(array $params = [])
    {
        list($response) = $this->getNewsCommentsWithHttpInfo($params);
        return $response;
    }

    /**
     * Operation getNewsCommentsWithHttpInfo
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "order_by" string  how to order comments (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNewsCommentsWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getNewsCommentsRequest($params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNewsCommentsAsync
     *
     * 
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "order_by" string  how to order comments (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNewsCommentsAsync(array $params = [])
    {
        return $this->getNewsCommentsAsyncWithHttpInfo($params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNewsCommentsAsyncWithHttpInfo
     *
     * 
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "order_by" string  how to order comments (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNewsCommentsAsyncWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getNewsCommentsRequest($params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNewsComments'
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "status" string  filter by status (optional)
     *   "is_reviewed" int  filter by reviewed status (optional)
     *   "period_created" string  filter by period (optional)
     *   "article" int  select comments for article with given id (optional)
     *   "download" int  select comments for download with given id (optional)
     *   "news" int  select comments for news with given id (optional)
     *   "order_by" string  how to order comments (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNewsCommentsRequest(array $params = [])
    {
        if (!isset($params['page'])) {
            $params['page'] = null;
        }
        if (!isset($params['count'])) {
            $params['count'] = null;
        }
        if (!isset($params['limit'])) {
            $params['limit'] = null;
        }
        if (!isset($params['ids'])) {
            $params['ids'] = null;
        }
        if (!isset($params['status'])) {
            $params['status'] = null;
        }
        if (!isset($params['is_reviewed'])) {
            $params['is_reviewed'] = null;
        }
        if (!isset($params['period_created'])) {
            $params['period_created'] = null;
        }
        if (!isset($params['article'])) {
            $params['article'] = null;
        }
        if (!isset($params['download'])) {
            $params['download'] = null;
        }
        if (!isset($params['news'])) {
            $params['news'] = null;
        }
        if (!isset($params['order_by'])) {
            $params['order_by'] = null;
        }
        

        $resourcePath = '/news_comments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($params['page'] !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($params['page']);
        }
        // query params
        if ($params['count'] !== null) {
            $queryParams['count'] = ObjectSerializer::toQueryValue($params['count']);
        }
        // query params
        if ($params['limit'] !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($params['limit']);
        }
        // query params
        if ($params['ids'] !== null) {
            $queryParams['ids'] = ObjectSerializer::toQueryValue($params['ids']);
        }
        // query params
        if ($params['status'] !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($params['status']);
        }
        // query params
        if ($params['is_reviewed'] !== null) {
            $queryParams['is_reviewed'] = ObjectSerializer::toQueryValue($params['is_reviewed']);
        }
        // query params
        if ($params['period_created'] !== null) {
            $queryParams['period_created'] = ObjectSerializer::toQueryValue($params['period_created']);
        }
        // query params
        if ($params['article'] !== null) {
            $queryParams['article'] = ObjectSerializer::toQueryValue($params['article']);
        }
        // query params
        if ($params['download'] !== null) {
            $queryParams['download'] = ObjectSerializer::toQueryValue($params['download']);
        }
        // query params
        if ($params['news'] !== null) {
            $queryParams['news'] = ObjectSerializer::toQueryValue($params['news']);
        }
        // query params
        if ($params['order_by'] !== null) {
            $queryParams['order_by'] = ObjectSerializer::toQueryValue($params['order_by']);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNewsCount
     *
     *
     * Parameters:
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group counters (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getNewsCount(array $params = [])
    {
        list($response) = $this->getNewsCountWithHttpInfo($params);
        return $response;
    }

    /**
     * Operation getNewsCountWithHttpInfo
     *
     * Parameters:
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group counters (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNewsCountWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getNewsCountRequest($params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNewsCountAsync
     *
     * 
     *
     * Parameters:
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group counters (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNewsCountAsync(array $params = [])
    {
        return $this->getNewsCountAsyncWithHttpInfo($params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNewsCountAsyncWithHttpInfo
     *
     * 
     *
     * Parameters:
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group counters (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNewsCountAsyncWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getNewsCountRequest($params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNewsCount'
     *
     * Parameters:
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "category" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group counters (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNewsCountRequest(array $params = [])
    {
        if (!isset($params['author'])) {
            $params['author'] = null;
        }
        if (!isset($params['category'])) {
            $params['category'] = null;
        }
        if (!isset($params['group_by'])) {
            $params['group_by'] = null;
        }
        if (!isset($params['status'])) {
            $params['status'] = null;
        }
        if (!isset($params['hidden_status'])) {
            $params['hidden_status'] = null;
        }
        if (!isset($params['period_created'])) {
            $params['period_created'] = null;
        }
        if (!isset($params['period_last_comment'])) {
            $params['period_last_comment'] = null;
        }
        if (!isset($params['period_published'])) {
            $params['period_published'] = null;
        }
        if (!isset($params['period_updated'])) {
            $params['period_updated'] = null;
        }
        

        $resourcePath = '/news/counts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($params['author'] !== null) {
            $queryParams['author'] = ObjectSerializer::toQueryValue($params['author']);
        }
        // query params
        if ($params['category'] !== null) {
            $queryParams['category'] = ObjectSerializer::toQueryValue($params['category']);
        }
        // query params
        if ($params['group_by'] !== null) {
            $queryParams['group_by'] = ObjectSerializer::toQueryValue($params['group_by']);
        }
        // query params
        if ($params['status'] !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($params['status']);
        }
        // query params
        if ($params['hidden_status'] !== null) {
            $queryParams['hidden_status'] = ObjectSerializer::toQueryValue($params['hidden_status']);
        }
        // query params
        if ($params['period_created'] !== null) {
            $queryParams['period_created'] = ObjectSerializer::toQueryValue($params['period_created']);
        }
        // query params
        if ($params['period_last_comment'] !== null) {
            $queryParams['period_last_comment'] = ObjectSerializer::toQueryValue($params['period_last_comment']);
        }
        // query params
        if ($params['period_published'] !== null) {
            $queryParams['period_published'] = ObjectSerializer::toQueryValue($params['period_published']);
        }
        // query params
        if ($params['period_updated'] !== null) {
            $queryParams['period_updated'] = ObjectSerializer::toQueryValue($params['period_updated']);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTopicById
     *
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getTopicById(array $params = [])
    {
        list($response) = $this->getTopicByIdWithHttpInfo($params);
        return $response;
    }

    /**
     * Operation getTopicByIdWithHttpInfo
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTopicByIdWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getTopicByIdRequest($params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTopicByIdAsync
     *
     * 
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTopicByIdAsync(array $params = [])
    {
        return $this->getTopicByIdAsyncWithHttpInfo($params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTopicByIdAsyncWithHttpInfo
     *
     * 
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTopicByIdAsyncWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getTopicByIdRequest($params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTopicById'
     *
     * Parameters:
     *   "id" int  The id of the resource (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTopicByIdRequest(array $params = [])
    {
        if (empty($params['id'])) {
            throw new \InvalidArgumentException('Missing parameter "id" in ContentApi::getTopicByIdRequest().');
        }
        

        $resourcePath = '/topics/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($params['id'] !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($params['id']),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTopicCount
     *
     *
     * Parameters:
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "guide" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group counters (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getTopicCount(array $params = [])
    {
        list($response) = $this->getTopicCountWithHttpInfo($params);
        return $response;
    }

    /**
     * Operation getTopicCountWithHttpInfo
     *
     * Parameters:
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "guide" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group counters (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTopicCountWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getTopicCountRequest($params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTopicCountAsync
     *
     * 
     *
     * Parameters:
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "guide" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group counters (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTopicCountAsync(array $params = [])
    {
        return $this->getTopicCountAsyncWithHttpInfo($params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTopicCountAsyncWithHttpInfo
     *
     * 
     *
     * Parameters:
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "guide" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group counters (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTopicCountAsyncWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getTopicCountRequest($params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTopicCount'
     *
     * Parameters:
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "guide" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group counters (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTopicCountRequest(array $params = [])
    {
        if (!isset($params['author'])) {
            $params['author'] = null;
        }
        if (!isset($params['guide'])) {
            $params['guide'] = null;
        }
        if (!isset($params['group_by'])) {
            $params['group_by'] = null;
        }
        if (!isset($params['status'])) {
            $params['status'] = null;
        }
        if (!isset($params['hidden_status'])) {
            $params['hidden_status'] = null;
        }
        if (!isset($params['period_created'])) {
            $params['period_created'] = null;
        }
        if (!isset($params['period_last_comment'])) {
            $params['period_last_comment'] = null;
        }
        if (!isset($params['period_published'])) {
            $params['period_published'] = null;
        }
        if (!isset($params['period_updated'])) {
            $params['period_updated'] = null;
        }
        

        $resourcePath = '/topics/counts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($params['author'] !== null) {
            $queryParams['author'] = ObjectSerializer::toQueryValue($params['author']);
        }
        // query params
        if ($params['guide'] !== null) {
            $queryParams['guide'] = ObjectSerializer::toQueryValue($params['guide']);
        }
        // query params
        if ($params['group_by'] !== null) {
            $queryParams['group_by'] = ObjectSerializer::toQueryValue($params['group_by']);
        }
        // query params
        if ($params['status'] !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($params['status']);
        }
        // query params
        if ($params['hidden_status'] !== null) {
            $queryParams['hidden_status'] = ObjectSerializer::toQueryValue($params['hidden_status']);
        }
        // query params
        if ($params['period_created'] !== null) {
            $queryParams['period_created'] = ObjectSerializer::toQueryValue($params['period_created']);
        }
        // query params
        if ($params['period_last_comment'] !== null) {
            $queryParams['period_last_comment'] = ObjectSerializer::toQueryValue($params['period_last_comment']);
        }
        // query params
        if ($params['period_published'] !== null) {
            $queryParams['period_published'] = ObjectSerializer::toQueryValue($params['period_published']);
        }
        // query params
        if ($params['period_updated'] !== null) {
            $queryParams['period_updated'] = ObjectSerializer::toQueryValue($params['period_updated']);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTopics
     *
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "guide" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group downloads (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *   "order_by" int  how to order (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function getTopics(array $params = [])
    {
        list($response) = $this->getTopicsWithHttpInfo($params);
        return $response;
    }

    /**
     * Operation getTopicsWithHttpInfo
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "guide" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group downloads (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *   "order_by" int  how to order (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTopicsWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getTopicsRequest($params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTopicsAsync
     *
     * 
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "guide" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group downloads (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *   "order_by" int  how to order (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTopicsAsync(array $params = [])
    {
        return $this->getTopicsAsyncWithHttpInfo($params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTopicsAsyncWithHttpInfo
     *
     * 
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "guide" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group downloads (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *   "order_by" int  how to order (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTopicsAsyncWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->getTopicsRequest($params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTopics'
     *
     * Parameters:
     *   "page" int  Which page to display (optional)
     *   "count" int  Resource per page count (optional)
     *   "limit" int  Max number of resources to return (optional)
     *   "ids" string  Comma separated list of IDs (optional)
     *   "author" string  filter by author, provide an id or &#39;me&#39; for current user (optional)
     *   "guide" int  filter category, could be an array or just digit (optional)
     *   "group_by" string  how to group downloads (optional)
     *   "status" string  filter by status (optional)
     *   "hidden_status" int  select for article with given id (optional)
     *   "period_created" int  filter by period when content was created (optional)
     *   "period_last_comment" int  filter by period when content was last commented (optional)
     *   "period_published" int  filter by py period when content was published (optional)
     *   "period_updated" int  filter by py period when content was updated (optional)
     *   "order_by" int  how to order (optional)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTopicsRequest(array $params = [])
    {
        if (!isset($params['page'])) {
            $params['page'] = null;
        }
        if (!isset($params['count'])) {
            $params['count'] = null;
        }
        if (!isset($params['limit'])) {
            $params['limit'] = null;
        }
        if (!isset($params['ids'])) {
            $params['ids'] = null;
        }
        if (!isset($params['author'])) {
            $params['author'] = null;
        }
        if (!isset($params['guide'])) {
            $params['guide'] = null;
        }
        if (!isset($params['group_by'])) {
            $params['group_by'] = null;
        }
        if (!isset($params['status'])) {
            $params['status'] = null;
        }
        if (!isset($params['hidden_status'])) {
            $params['hidden_status'] = null;
        }
        if (!isset($params['period_created'])) {
            $params['period_created'] = null;
        }
        if (!isset($params['period_last_comment'])) {
            $params['period_last_comment'] = null;
        }
        if (!isset($params['period_published'])) {
            $params['period_published'] = null;
        }
        if (!isset($params['period_updated'])) {
            $params['period_updated'] = null;
        }
        if (!isset($params['order_by'])) {
            $params['order_by'] = null;
        }
        

        $resourcePath = '/topics';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($params['page'] !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($params['page']);
        }
        // query params
        if ($params['count'] !== null) {
            $queryParams['count'] = ObjectSerializer::toQueryValue($params['count']);
        }
        // query params
        if ($params['limit'] !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($params['limit']);
        }
        // query params
        if ($params['ids'] !== null) {
            $queryParams['ids'] = ObjectSerializer::toQueryValue($params['ids']);
        }
        // query params
        if ($params['author'] !== null) {
            $queryParams['author'] = ObjectSerializer::toQueryValue($params['author']);
        }
        // query params
        if ($params['guide'] !== null) {
            $queryParams['guide'] = ObjectSerializer::toQueryValue($params['guide']);
        }
        // query params
        if ($params['group_by'] !== null) {
            $queryParams['group_by'] = ObjectSerializer::toQueryValue($params['group_by']);
        }
        // query params
        if ($params['status'] !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($params['status']);
        }
        // query params
        if ($params['hidden_status'] !== null) {
            $queryParams['hidden_status'] = ObjectSerializer::toQueryValue($params['hidden_status']);
        }
        // query params
        if ($params['period_created'] !== null) {
            $queryParams['period_created'] = ObjectSerializer::toQueryValue($params['period_created']);
        }
        // query params
        if ($params['period_last_comment'] !== null) {
            $queryParams['period_last_comment'] = ObjectSerializer::toQueryValue($params['period_last_comment']);
        }
        // query params
        if ($params['period_published'] !== null) {
            $queryParams['period_published'] = ObjectSerializer::toQueryValue($params['period_published']);
        }
        // query params
        if ($params['period_updated'] !== null) {
            $queryParams['period_updated'] = ObjectSerializer::toQueryValue($params['period_updated']);
        }
        // query params
        if ($params['order_by'] !== null) {
            $queryParams['order_by'] = ObjectSerializer::toQueryValue($params['order_by']);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateGuideByGuideIdTree
     *
     *
     * Parameters:
     *   "guide_id" string   (required)
     *   "tree" string[]   (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \DeskPRO\API\Model\Response
     */
    public function updateGuideByGuideIdTree(array $params = [])
    {
        list($response) = $this->updateGuideByGuideIdTreeWithHttpInfo($params);
        return $response;
    }

    /**
     * Operation updateGuideByGuideIdTreeWithHttpInfo
     *
     * Parameters:
     *   "guide_id" string   (required)
     *   "tree" string[]   (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \DeskPRO\API\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \DeskPRO\API\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateGuideByGuideIdTreeWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->updateGuideByGuideIdTreeRequest($params);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse()->getBody()->getContents()
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\DeskPRO\API\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateGuideByGuideIdTreeAsync
     *
     * 
     *
     * Parameters:
     *   "guide_id" string   (required)
     *   "tree" string[]   (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateGuideByGuideIdTreeAsync(array $params = [])
    {
        return $this->updateGuideByGuideIdTreeAsyncWithHttpInfo($params)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateGuideByGuideIdTreeAsyncWithHttpInfo
     *
     * 
     *
     * Parameters:
     *   "guide_id" string   (required)
     *   "tree" string[]   (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateGuideByGuideIdTreeAsyncWithHttpInfo(array $params = [])
    {
        $returnType = '\DeskPRO\API\Model\Response';
        $request = $this->updateGuideByGuideIdTreeRequest($params);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                                        if (isset($content->data)) {
                                            $content = $content->data;
                                        }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateGuideByGuideIdTree'
     *
     * Parameters:
     *   "guide_id" string   (required)
     *   "tree" string[]   (required)
     *
     * @param array $params API endpoint parameters
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateGuideByGuideIdTreeRequest(array $params = [])
    {
        if (empty($params['guide_id'])) {
            throw new \InvalidArgumentException('Missing parameter "guide_id" in ContentApi::updateGuideByGuideIdTreeRequest().');
        }
        if (empty($params['tree'])) {
            throw new \InvalidArgumentException('Missing parameter "tree" in ContentApi::updateGuideByGuideIdTreeRequest().');
        }
        

        $resourcePath = '/guides/{guideId}/tree';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($params['tree'])) {
            $params['tree'] = ObjectSerializer::serializeCollection($params['tree'], 'csv', true);
        }
        if ($params['tree'] !== null) {
            $queryParams['tree'] = ObjectSerializer::toQueryValue($params['tree']);
        }

        // path params
        if ($params['guide_id'] !== null) {
            $resourcePath = str_replace(
                '{' . 'guideId' . '}',
                ObjectSerializer::toPathValue($params['guide_id']),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers= $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
